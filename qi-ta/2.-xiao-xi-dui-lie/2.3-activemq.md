# 2.3 ActiveMq

       AcitveMQ是作为一种**消息存储**和**分发组件**，涉及到client与broker端数据交互的方方面面，它不仅要**担保**消息的存储**安全性**，还要提供额外的手段来确保消息的分发是**可靠的**。

## 1. ActiveMQ消息传送机制 

1. **Producer客户端**使用来**发送**消息的， **Consumer客户端**用来**消费**消息；
2. 它们的协同中心就是ActiveMQ broker, **broker**也是让**producer**和**consumer**调用**过程解耦**的工具，最终实现了**异步RPC/数据交换**的功能。随着ActiveMQ的不断发展，支持了越来越多的特性，也解决开发者在各种场景下使用ActiveMQ的需求。比如producer支持异步调用；
3. 使用flow **control**机制让broker协同consumer的消费速率；
4. **consumer**端可以使用**prefetchACK**来最大化消息消费的速率；
5. 提供”重发策略”等来提高消息的安全性等。

 一条消息的生命周期如下:

![](../../.gitbook/assets/image%20%2876%29.png)

图片中简单的描述了一条消息的生命周期,不过在不同的架构环境中,message的流动行可能更加复杂。一条消息从producer端发出之后，一旦被broker正确保存，那么它将会被consumer消费，然后ACK，broker端才会删除；不过当消息过期或者存储设备溢出时，也会终结它。

![](../../.gitbook/assets/image%20%28317%29.png)

## 2. Jms与ActiveMQ的结合

* JMS是一个**用于提供消息服务的技术规范**，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。
* 而MQ则是**消息队列服务**，是**面向消息中间件（MOM）**的最终实现，是真正的服务提供者；MQ的实现可以**基于JMS**，也可以基于其他规范或标准。目前选择的最多的是ActiveMQ。

JMS支持两种消息传递模型：点对点（point-to-point，简称PTP）和发布/订阅（publish/subscribe,简称pub/sub）。这两种消息传递模型非常相似，但有以下区别:

* PTP消息传递模型规定了一条消息只能够传递给一个接收方。
* Pub/sub消息传递模型允许一条消息传递给多个接收方 

### 2.1 点对点模型 

通过点对点的消息传递模型，一个应用程序可以向另外一个应用程序发送消息。在此传递模型中，目标类型是**队列**。消息首先被传送至队列目标，然后从该队列将消息传送至对此队列进行监听的某个消费者，如下图:

![](../../.gitbook/assets/image%20%28153%29.png)

* 一个队列可以关联**多个队列发送方和接收方**，**但一条消息仅传递给一个接收方**。
* 如果多个接收方正在监听队列上的消息，JMS Provider将根据“**先来者优先**”的原则确定由哪个发送方接受下一条消息。
* 如果没有接收方在监听队列，消息**将保留在队列中**，直至接收方连接到队列为止。

这种消息传递模型是传统意义上的**拉模型或轮询模型**。在此列模型中，消息不时自动推动给客户端的，而是要由客户端从队列中请求获得。 

###  2.2 发布/订阅模型 

通过发布/订阅消息传递模型，应用程序能够将**一条消息发送到多个接收方**。在此传送模型中，目标类型是**主题**。消息首先被传送至主题目标，然后**传送至所有已订阅此主题的**消费者。如下图：

![](../../.gitbook/assets/image%20%28256%29.png)

* 主题目标也支持长期订阅。长期订阅表示消费者已注册了主题目标，但在消息到达目标时该消费者可以处于非活动状态。当消费者再次处于活动状态时，将会接收该消息。如果消费者均没有注册某个主题目标，该主题只保留注册了长期订阅的非活动消费者的消息。
* 与PTP消息传递模型不同，pub/sub消息传递模型允许**多个主题订阅者接收同一条消息**。**JMS一直保留消息，直至所有主题订阅者都接收到消息为止**。pub/sub消息传递模型基本上是一个**推模型**。在该模型中，消息会自动广播，消费者**无须通过主动请求或轮询主题的方法**来获得新的消息。 

       上面两种消息传递模型里，我们都需要**定义消息生产者和消费者**，生产者把消息发送到JMS Provider的**某个目标地址**（Destination），消息从该**目标地址**传送至**消费者**。消费者可以同步或异步接收消息，一般而言，**异步消息消费者的执行和伸缩性都优于同步消息接收者**，体现在： 

1.  异步消息接收者创建的**网络流量比较小**。单向对等消息，并使之通过管道进入消息监听器。管道操作支持将**多条消息聚合为一个网络**调用。 
2. 异步消息接收者使用**线程比较少**。异步消息接收者在不活动期间不使用线程。同步消息接收者在接收调用期间内使用线程，结果线程可能会长时间保持空闲，尤其是如果该调用中指定了阻塞超时。 
3. 对于服务器上运行的应用程序代码，**使用异步消息接收者几乎总是最佳选择，尤其是通过消息驱动Bean。**使用异步消息接收者可以防止应用程序代码在服务器上执行**阻塞操**作。而阻塞操作会是服务器端线程空闲，甚至会导致死锁。阻塞操作使用所有线程时则发生死锁。如果没有空余的线程可以处理阻塞操作自身解锁所需的操作，这该操作永远无法停止阻塞。 

###  2.3 Queue与Topic的比较 

1. JMS Queue执行**load balancer**语义 

           一条消息**仅能被一个consumer收到**。如果在message发送的时候没有可用的consumer，那么它将被保存一直到能处理该message的consumer可用。如果一个consumer收到一条message后**却不响应它**，那么这条消息将被转到另外一个consumer那儿。一个Queue可以有很多consumer，并且在多个可用的consumer中**负载均衡**。 

2. Topic实现**publish**和**subscribe**语义 

            一条消息被publish时，他将发送给所有感兴趣的订阅者，所以零到多个subscriber将接收到消息的一个拷贝。但是在消息代理接收到消息时，只有**激活订阅**的subscriber能够获得消息的一个拷贝。 

3. 分别对应两种消息模式 

           Point-to-Point\(**点对点**\)，Publisher/Subscriber Model\(**发布/订阅者**\) 其中在Publicher/Subscriber模式下又有Nondurable subscription\(**非持久化订阅**\)和durable subscription\(**持久化订阅**\)两种消息处理方式。

## 3. ActiveMQ优缺点 

     优点：是一个快速的开源消息组件\(框架\)，支持集群，同等网络，自动检测，TCP，SSL，广播，持久化，XA，和J2EE1.4容器无缝结合，并且支持轻量级容器和大多数跨语言客户端上的Java虚拟机。消息异步接受，减少软件多系统集成的耦合度。消息可靠接收，确保消息在中间件可靠保存，多个消息也可以组成原子事务。 

缺点：ActiveMQ默认的配置性能偏低，需要优化配置，但是配置文件复杂，ActiveMQ本身不提供管理工具；示例代码少；主页上的文档看上去比较全面，但是缺乏一种有效的组织方式，文档只有片段，用户很难由浅入深进行了解。



