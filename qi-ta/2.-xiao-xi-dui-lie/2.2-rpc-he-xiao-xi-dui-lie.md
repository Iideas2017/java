# 2.2 RPC和消息队列

## 1. 功能特点 

        在架构上，RPC和Message Queue的差异点是，Message Queue有一个中间结点Message Queue\(broker\)，可以把**消息存储**。 

## 2. 消息队列的特点 

* Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。 
* Message Queue引入一下**新的结点**，让系统的可靠性会受**Message Queue结点**的影响。 
* Message Queue是**异步单向**的消息。发送消息设计成是**不需要等待消息**处理的完成。 所以对于有同步返回需求，用Message Queue则变得麻烦了。 

## 3. RPC的特点 

* **同步调用**，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式。RPC也可以是异步调用。 
* 由于等待结果，Consumer（Client）会有**线程消耗**。 如果以**异步RPC**的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。 

## 4. RPC适用场合说明 

* 希望同步得到结果的场合，RPC合适。 
* 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。 
* 不希望发送端（RPC Consumer、Message Sender）**受限于处理端**（RPC Provider、Message Receiver）的**速度**时，使用Message Queue。 

    随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。这样的改造实际上有调整业务的使用方式。 比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。

##  5. RPC不适用场合说明 

* RPC同步调用使用Message Queue来传输调用信息。 上面分析可以知道，这样的做法，发送端是在等待，同时占用一个中间点的资源。变得复杂了，但没有对等的收益。
* 对于返回值是void的调用，可以这样做，因为实际上这个调用业务上往往不需要同步得到处理结果的，只要保证会处理即可。（RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。） 返回值是void的调用，使用消息，效果上是把消息的使用方式Wrap成了服务调用（服务调用使用方式成简单，基于业务接口）。 

