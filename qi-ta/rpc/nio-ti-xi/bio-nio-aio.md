# 1. BIO、NIO、AIO

## 1. 基础

| **名词** | **解释** | **举例** |
| :--- | :--- | :--- |
| 同步 | 用户进程触发IO操作并**等待或者轮询**的去查看IO操作是否就绪 | 自己上街买衣服，自己亲自干这件事，别的事干不了。 |
| 异步 | 用户进程触发IO操作以后便**开始做自己的事情**，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是**通知**） | 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS） |
| 阻塞 | 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入**等待状态**, 直到有东西可读或者可写为止 | 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。） |
| 非阻塞 | 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 | 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。 |

 1 **同步和异步**是针对**应用程序和内核的交互**而言的。

 同步/异步是在时间上**强调处理事情的结果/机会成本**的两种处理策略：         

         **强调结果**意味着对结果的迫不急待，不过结果是正确的还是错误的，反正你要立即给我一个结果响应；                                                                                                                                     

        **强调时间机会成本**意味着对等待结果浪费的时间极其难接受，而对结果并不是那么急切，暂时不管结果（让处理方处理完主动通知结果/自己空闲的时候主动去获取结果）转而去处理其他事情

2 **同步/异步**是宏观上（**进程间通讯**，通常表现为**网络IO**的处理上），阻塞/非阻塞是微观上（**进程内数据传输**，通常表现为**对本地IO的处理上**）；**阻塞和非阻塞是同步/异步的表现形式**

3 **阻塞和非阻塞**是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种**读取或者写入操作函数的实现方式**，阻塞方式下读取或者写入函数将**一直等待**，而非阻塞方式下，读取或者写入函数会立即**返回一个状态值**。

由上描述基本可以总结一句简短的话，同步和异步是**目的**，阻塞和非阻塞是**实现方式**。 

## 2. 定义

**BIO**：**同步阻塞**，每一个**socket套接字**需要使用**一个线程**来处理。建立连接、进行读写操作的时候都可能阻塞。在服务器端如果要支持并发的连接时，需要更多的线程。连接不做任何事情的时候会造成不必要的线程开销，可通过线程池来改善。

![BIO](../../../.gitbook/assets/image%20%28246%29.png)

![](../../../.gitbook/assets/image%20%2865%29.png)

**NIO** ： **同步非阻塞**，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 NIO的主要的两种形式：select和epoll 

![](../../../.gitbook/assets/image%20%28258%29.png)

![](../../../.gitbook/assets/image%20%28342%29.png)

**AIO** ： **异步非阻塞**，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， NIO方式适用于**连接数目多且连接比较短**（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于**连接数目多且连接比较长**（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持 I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。另外NIO的非阻塞，需要一直轮询，也是一个比较耗资源的。

![](../../../.gitbook/assets/image%20%28363%29.png)

![](../../../.gitbook/assets/image%20%28214%29.png)

## 3. 比较

![](../../../.gitbook/assets/image%20%28190%29.png)

     BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。   
  
    NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。   
  
    AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

## 4. Reactor模式和Proactor模式

       **NIO\(同步非阻塞\)** 基于**事件驱动**\(在程序里，程序停止在那不动，你点击一个按钮，它就有反应了，过一会，又没反应了，你再点一下，它又继续运行\)，采用的Reactor模式，\(Reactor模式首先是**事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers**；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。\)Reactor会处理所有客户端的Socket套接字的事件，然后派发到不同的线程中。这样就解决了BIO中为了支撑更多的Socket套接字而需要更多的线程。

      **AIO（异步非阻塞）**AIO采用了Proactor模式，AIO与NIO的不同之处在于**当AIO在进行读写操作时**，**不用先等通知**，可**直接调用**相应的**read/write**方法，这两种方法均为**异步**的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序,而NIO的通知是发生在动作之前的，是在可读、写的时候，Selector发现了这些事件后调用Handler处理。  
    
（其实阻塞与非阻塞都可以理解为同步范畴下才有的概念，对于异步，就不会再去分阻塞非阻塞。对于用户进程，接到异步通知后，就直接操作进程用户态空间里的数据好了。）  

### 4.1 Reactor模式

Reactor模式应用于同步I/O的场景。我们分别以读操作和写操作为例来看看Reactor中的具体步骤：    
读取操作：    
1. 应用程序注册读就绪事件和相关联的事件处理器    
2. 事件分离器等待事件的发生    
3. 当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器    
4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理    
写入操作类似于读取操作，只不过第一步注册的是写就绪事件。  

### 4.2 Proactor模式

读取操作：    
1. 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。    
2. 事件分离器等待读取操作完成事件    
3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步IO都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作，操作系统扮演了重要角色），并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。    
4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。    
    
Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。  

### 4.3 总结

         从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.    
     
          综上所述，同步和异步是相对于应用和内核的交互方式而言的，同步 **需要主动去询问**，而异步的时候**内核在IO事件发生的时候通知应用程序**，而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。  

