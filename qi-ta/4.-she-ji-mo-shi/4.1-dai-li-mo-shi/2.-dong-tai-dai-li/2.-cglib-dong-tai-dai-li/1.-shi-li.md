# 1. 示例

## 1. 导入包

![](../../../../../.gitbook/assets/image%20%28298%29.png)

## 2. 被代理类

![](../../../../../.gitbook/assets/image%20%28394%29.png)

## 3. 方法拦截器

![&#x5B9E;&#x73B0;MethodInterceptor&#x63A5;&#x53E3;&#x751F;&#x6210;&#x65B9;&#x6CD5;&#x62E6;&#x622A;&#x5668;](../../../../../.gitbook/assets/image%20%2857%29.png)

## 4. 执行

![&#x751F;&#x6210;&#x4EE3;&#x7406;&#x7C7B;&#x5BF9;&#x8C61;&#x5E76;&#x6253;&#x5370;&#x5728;&#x4EE3;&#x7406;&#x7C7B;&#x5BF9;&#x8C61;&#x8C03;&#x7528;&#x65B9;&#x6CD5;&#x4E4B;&#x540E;&#x7684;&#x6267;&#x884C;&#x7ED3;&#x679C;](../../../../../.gitbook/assets/image%20%2888%29.png)

JDK代理要求被代理的类必须实现接口，有很强的局限性。而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理\(前置处理、后置处理等\)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。  
  


