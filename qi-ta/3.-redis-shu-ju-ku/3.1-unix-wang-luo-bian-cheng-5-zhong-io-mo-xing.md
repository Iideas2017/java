# 3.1 Unix网络编程5种I/O模型

## 1.I/O 模型

### 1.1 阻塞式I/O模型

    进程调用recvfrom，其系统调用直到数据报到达且**被拷贝到应用进程的缓冲区中**或者发生错误才返回。进程从调用recvfrom开始到它返回的整段时间内是被阻塞的。

![](../../.gitbook/assets/image%20%28107%29.png)

### 1.2 非阻塞式I/O模型

![](../../.gitbook/assets/image%20%28115%29.png)

 当一个应用进程像这样对一个非阻塞描述字循环调用recvfrom时，我们称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪。

### 1.3 I/O多路复用（事件驱动）模型

![](../../.gitbook/assets/image%20%28104%29.png)

### 1.4 信号驱动式I/O\(SIGIO\)

![](../../.gitbook/assets/image%20%28193%29.png)

### 1.5 异步I/O模型

![](../../.gitbook/assets/image%20%28176%29.png)

### 1.6 I/O模型的比较

![](../../.gitbook/assets/image%20%28207%29.png)

     根据上述5种IO模型，前4种模型-阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步I/O模型，因为其中真正的I/O操作（recvfrom）将阻塞进程，在内核数据copy到用户空间时都是阻塞的。

### 1.7 IO多路复用

IO多路复用，就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

IO多路复用方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。  
由于**select函数是阻塞**的，因此多路IO复用模型也被称为**异步阻塞IO模型**。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。  
IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。

![](../../.gitbook/assets/image%20%28205%29.png)

### 1.8 select、poll、epoll

Linux支持IO多路复用的系统调用有select、poll、epoll，这些调用都是内核级别的。但select、poll、epoll本质上都是同步I/O，先是block住等待就绪的socket，再是block住将数据从内核拷贝到用户内存。

![](../../.gitbook/assets/image%20%2853%29.png)

select、poll、epoll之间的区别，如下表：

![](../../.gitbook/assets/image%20%2839%29.png)

### 1.9 两种I/O多路复用模式：Reactor和Proactor

在这两种模式下的事件多路分离器反馈给程序的信息是不一样的：  
1.Reactor模式下说明你可以进行读写（收发）操作了。  
2.Proactor模式下说明已经完成读写（收发）操作了，具体内容在给定缓冲区中，可以对这些内容进行其他操作了。  
Reactor关注的是I/O操作的就绪事件，而Proactor关注的是I/O操作的完成事件

一般地,I/O多路复用机制都依赖于一个事件多路分离器\(Event Demultiplexer\)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器\(Event Handler\)。

Reactor模式采用**同步IO**，而Proactor采用**异步IO**。

在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。

而在Proactor模式中，处理器或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。

Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.

