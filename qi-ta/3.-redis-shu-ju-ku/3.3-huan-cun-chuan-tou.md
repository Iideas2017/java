# 3.3 缓存穿透

## 1. 缓存穿透

### 1.1 什么是缓存穿透？

       所谓的缓存穿透，简单来讲就是查询某些不存在的key时，缓存和数据库查询结果都为空，而空的结果又不被缓存起来，而导致每次查询都去请求数据库层的情况。

     **缓存不命中**，进而导致**每次查询都去查询数据库**，缓存也就失去了作用，通常表现为服务器负载迅速上升，严重时可能直接宕机。

![](../../.gitbook/assets/image%20%2897%29.png)

### 1.2 如何避免？

 缓存空数据和使用布隆过滤器

#### 1. 缓存空数据

当第一次查询数据库时，若数据不存在，返回空数据时将其写入缓存，后续查询就不必再去查询数据库了。

![](../../.gitbook/assets/image%20%2854%29.png)

     存在问题：如果key过期时间较长，出现恶意攻击时，容易出现**内存不够**的情况。另外，需要额外的业务逻辑处理数据库与缓存中数据一致性的问题。

#### 2. 布隆过滤器拦截

访问缓存之前，先从布隆过滤器中验证数据是否存在。

![](../../.gitbook/assets/image%20%28113%29.png)

简单来讲就是使用**多个hash函数**将**一个key映射到一个很长的二进制向量的多个比特位中**，类似于**hash set**。

存在问题：维护复杂，建议只在海量数据的情况下使用。

## 2. 缓存雪崩

### 2.1 什么是缓存雪崩？

       缓存雪崩就是**指缓存由于某些原因（比如 宕机、cache服务挂了或者不响应）整体crash掉了，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。**

### 2.2 如何避免？

1：在缓存失效后，通过**加锁或者队列**来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

2：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

3：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

#### **1）事前解决方案**

* 保证缓存层服务高可用性

和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。

**部署方式一**：双机房部署，一套Redis Cluster，部分机器在一个机房，另一部分机器在另外一个机房。

**部署方式二**：双机房部署，两套Redis Cluster，两套Redis Cluster之间做一个数据同步。

#### **2）事中解决方案：**

* 对缓存访问进行 **资源隔离（熔断）**、**Fail Silent 降级**

避免所有资源hang在访问缓存上，当判断缓存出现问题，则自动进行熔断并按预设进行降级操作。

* ehcache本地缓存

应对零散的缓存中数据被清除掉的现象，另外一个主要预防缓存彻底崩溃，ehcache的缓存还能支撑一阵。

* 对源服务访问进行 限流、资源隔离（熔断）、Stubbed 降级。

无论是缓存层还是存储层都会有出错的概率，可以将它们视同为资源。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部 hang 在这个资源上，造成整个系统不可用。相信大家一定遇到过这样的页面：这些应该就是淘宝的降级策略。

![](../../.gitbook/assets/image%20%28101%29.png)

 降级在高并发系统中是非常正常的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。

#### **3\)事后解决方案**

* Redis数据备份和恢复
* 快速缓存预热

