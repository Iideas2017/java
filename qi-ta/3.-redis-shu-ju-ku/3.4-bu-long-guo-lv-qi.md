# 3.4 布隆过滤器

## 1. 简介

布隆在1970年提出了布隆过滤器（Bloom Filter），是一个很长的二进制向量（可以想象成一个序列）和一系列随机映射函数（hash function）。   
布隆过滤器可以用于检索一个元素是否在一个集合中。   
**优点：占用空间小，查询快，时空优于其他，** 不需要存储key，节省空间  
**缺点：有误判，删除困难，但不会错报**

### 1.1 算法

 1. 首先需要**k个hash函数**，每个函数可以把**key散列成为1个整数；**  
 2. 初始化时，需要**一个长度为n比特的数组**，**每个比特位初始化为0**；  
 3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1；  
 4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

一个**空的布隆过滤器是一个m位的位数组**，所有位的值都为0。定义了k个不同的符合均匀随机分布的哈希函数，每个函数把集合元素映射到位数组的m位中的某一位。

添加一个元素：

```text
先把这个元素作为k个哈希函数的输入，拿到k个数组位置，然后把所有的这些位置置为1。
```

查询一个元素（测试这个元素是否在集合里）：

```text
把这个元素作为k个哈希函数的输入，得到k个数组位置。这些位置中只要有任意一个是0，元素肯定不在这个集合里。如果元素在集合里，那么这些位置在插入这个元素时都被置为1了。如果这些位置都是1，那么要么元素在集合里，要么所有这些位置是在其他元素插入过程中被偶然置为1了，导致了一次“误报”。
```

### 1.2 误判和错判

误判：不在的判断在；

错判：在的判断不在；

 所以一个简单的改进就是counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。添加时增加计数器，删除时减少计数器。

