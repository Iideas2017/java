# 1.3 Tomcat类加载机制

## 1. **Tomcat类加载体系结构**

![Tomcat&#x7C7B;&#x52A0;&#x8F7D;&#x4F53;&#x7CFB;&#x7ED3;&#x6784;](../../.gitbook/assets/image%20%28351%29.png)



* commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问（**Tomcat应用服务器和Web应用均可见的类**）；
* catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；（**Tomcat应用服务器可见**）
* sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于**所有Webapp可见**，但是对于Tomcat容器不可见；
* WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只**对当前Webapp可见**；

## 2. 不使用双亲委派机制的原因

### 2.1 问题

1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖**同一个第三方类库的不同版本**，不能要求**同一个类库在同一个服务器只有一份**，因此要保证**每个应用程序的类库都是独立的**，保证**相互隔离**；  
2. 部署在同一个web容器中相同的类库相同的版本可以**共享**。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。   
3. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库**隔离**开来。   
4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情；所以，**web容器需要支持 jsp 修改后不用重启**。

### 2.2 考虑

**隔离性**：Web应用之间的类加载器相互隔离，例如，一个使用Spring 2.5，一个使用 Spring 4.0，应用一个类加载器，Jar包覆盖无法加载。

**灵活性**：因为隔离，所以只针对一个Web应用进行重新部署，此时该Web应用的类加载器会重新创建，不会影响其他Web应用。如果采用一个，因为类间依赖杂乱无章，无法完整移除某个Web应用的类

**性能**：每个Web应用都有一个类加载器，因此不会搜索其他Web应用包含的包，性能好。

### 2.3 解决

 第一个问题，如果使用默认的类加载器机制，那么是无法加载**两个相同类库的不同版本**的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。

第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。

第三个问题和第一个问题一样。

我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改，**jsp 文件其实也就是class文件**，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。我们可以**直接卸载掉这jsp文件的类加载器**，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。

### 2.4 顺序

#### 1.默认：

（1）从缓存中加载；

（2）如果没有，从JVM的Bootstrap类加载器加载；

（3）如果没有，当前类加载器（按照WEB-INF/classes、lib顺序）；

（4）如果没有，从父类加载，父类采用默认的委派模式，即 System、Common、Shared。

#### 2. delegate=true；

（1）从缓存中加载；

（2）如果没有，从JVM的Bootstrap类加载器加载；

（3）如果没有，从父类加载，父类采用默认的委派模式，即 System、Common、Shared；

（4）如果没有，当前类加载器（按照WEB-INF/classes、lib顺序）.

