# 1.2类加载机制的破坏

双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。接下来讨论一下双亲委派模型的三次破坏

## **1.第一次破坏**

由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了**重写loadClass\(\)方法**，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal\(\)，而这个方法唯一逻辑就是去调用自己的loadClass\(\)。

解决方案：JDK1.2之后已不再提倡用户再去覆盖loadClass\(\)方法，应当把自己的**类加载逻辑写到findClass\(\)方法中**，在loadClass\(\)方法的逻辑里，如果父类加载器加载失败，则会**调用自己的findClass\(\)方法来完成加载**，这样就可以保证新写出来的类加载器是符合双亲委派模型的。

## **2.第二次破坏**

双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），**基础类**之所以称为“基础”，是因为它们**总是作为被用户代码调用的API**，但世事往往没有绝对的完美。如果基础类又要调用回用户的代码，那该么办？

解决方案：Java设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器\(Thread Context ClassLoader\)**。这个类加载器可以通过java.lang.Thread类的setContextClassLoader\(\) 方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。   
这种行为实际上就是打通了双亲委派模型的层次结构来**逆向使用类加载器**，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及**SPI的加载动作基本上都采用这种方式**，例如JNDI,JDBC,JCE,JAXB和JBI等。

## **3.第三次破坏**

双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的； 为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。

