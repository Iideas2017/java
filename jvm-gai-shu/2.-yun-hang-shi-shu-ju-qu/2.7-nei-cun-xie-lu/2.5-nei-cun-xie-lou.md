# 2.7.3 内存泄漏详情

## 一、内存泄漏

定义：一个不再被程序使用的对象或变量还在内存中占有存储空间。

由于java的JVM引入了垃圾回收机制，垃圾回收器会自动回收不再使用的对象，了解JVM回收机制的都知道JVM是使用引用计数法和可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。

## 二、情况

### 1、静态集合类

如**HashMap、LinkedList**等等。

        如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，**长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收**。

在使用Set、Vector、HashMap等集合类的时候需要特别注意，有可能会发生内存泄漏。当这些集合被定义成静态的时候，由于它们的生命周期跟应用程序一样长，这时候，就有可能会发生内存泄漏，看下面代码：

```java
class StaticTest
{
    private static Vector v = new Vector(10);
 
    public void init()
    {
        for (int i = 1; i < 100; i++)
        {
            Object object = new Object();
            v.add(object);
            object = null;
        }
    }
}

```

在上面的代码中，循环申请了`Object`对象，并添加到`Vector`中，然后将对象设置为`null`，可是这些对象因为被`Vector`引用着，因此并不能被GC回收，因此造成了内存泄漏。因此，要释放这些对象，还需要被它们从`Vector`删除，最简单的方法就是将`Vector`设置为`null`。

### 2、各种连接

如**数据库连接、网络连接和IO连接**等。

在对数据库进行操作的过程中，首先需要**建立与数据库的连接**，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。

### 3、变量不合理的作用域

一般而言，一个变量的定义的**作用范围大于其使用范围，很有可能会造成内存泄漏**。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

```java
public class UsingRandom {
private String msg;
public void receiveMsg(){
    readFromNet();// 从网络中接受数据保存到msg中
    saveDB();// 把msg保存到数据库中
}}
```

 如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了**内存泄漏**。

实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。

### 4、内部类持有外部类

如果**一个外部类的实例对象的方法返回了一个内部类的实例对象**，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但**由于内部类持有外部类的实例对象**，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

### 5、改变哈希值

当一个对象被存储进HashSet集合中以后，就**不能修改这个对象中的那些参与计算哈希值的字段了**，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会**导致无法从HashSet集合中单独删除当前对象，造成内存泄露。**

```java
public static void main(String[] args)
{
    Set<Student> set = new HashSet<Student>();
    Student s1 = new Student("Jack");
    Student s2 = new Student("Mary");
    Student s3 = new Student("Eason");
 
    set.add(s1);
    set.add(s2);
    set.add(s3);
 
    System.out.println(set.size());//3
    s2.setName("Jackson"); //修改属性，此时s2元素对应的hashcode值发生改变
    set.remove(s2);        // remove不掉，造成内存泄漏
    set.add(s2);           // 添加成功
 
    System.out.println(set.size());//4
}

```

在这个例子中，由于对象`s2`的属性值被改变了，因此不能从`set`中删除，所以`set`中会一直保持着`s2`的引用，不能被回收，造成了内存泄漏。

### **6、**单例模式

使用单例模式的时候也有可能导致内存泄漏。因为单例对象初始化后**将在JVM的整个生命周期内存在，如果它持有一个外部对象（生命周期比较短）的引用**，那么这个外部对象就不能被回收，而**导致内存泄漏**。如果这个外部对象还持有其它对象的引用，那么内存泄漏会更严重，因此需要特别注意此类情况。这种情况就需要考虑下单例模式的设计会不会有问题，应该怎样保证不会产生内存泄漏问题。

### 7、监听器

在Java中，我们经常会使用到监听器，如对某个控件添加单击监听器`addOnClickListener()`，但往往释放对象的时候会忘记删除监听器，这就有可能造成内存泄漏。好的方法就是，在释放对象的时候，应该记住释放所有监听器，这就能避免了因为监听器而导致的内存泄漏。

## **三、 GC 和** finalize\(\)

### 1、 gc\(\)

    对于程序员来说，GC基本是透明的，不可见的。运行GC的函数是System.gc\(\)，调用后启动垃圾回收器开始清理。

    但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。

    JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。

###  2、 finalize\(\)

    finalize\(\)是Object类中的方法。

    了解C++的都知道有个析构函数，但是注意，finalize\(\)绝不等于C++中的析构函数。

    Java编程思想中是这么解释的：一旦GC准备好释放对象所占用的的存储空间，将先调用其finalize\(\)方法，并在下一次GC回收动作发生时，才会真正回收对象占用的内存，所以一些清理工作，我们可以放到finalize\(\)中。

    该方法的一个重要的用途是：当在java中调用非java代码（如c和c++）时，在这些非java代码中可能会用到相应的申请内存的操作（如c的malloc\(\)函数），而在这些非java代码中并没有有效的释放这些内存，就可以使用finalize\(\)方法，并在里面调用本地方法的free\(\)等函数。

    所以finalize\(\)并不适合用作普通的清理工作。

    不过有时候，该方法也有一定的用处：

    如果存在一系列对象，对象中有一个状态为false，如果我们已经处理过这个对象，状态会变为true，为了避免有被遗漏而没有处理的对象，就可以使用finalize\(\)方法：

```java
class MyObject{
boolean state = false;
public void deal(){
//...一些处理操作
state = true;
}
@Override
protected void finalize(){
if(!state){
System.out.println("ERROR:" + "对象未处理！");
}
}
//...
}
```

