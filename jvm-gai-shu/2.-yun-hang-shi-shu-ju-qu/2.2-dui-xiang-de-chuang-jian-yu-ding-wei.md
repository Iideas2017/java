# 2.2 对象的内存结构

　　Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建和使用。在此，我们以最流行的HotSpot虚拟机以及常用的内存区域Java堆为例来探讨在虚拟机中对象的创建和对象的访问等问题。

## 1. 对象包含的内容

![](../../.gitbook/assets/image%20%28410%29.png)

![](../../.gitbook/assets/image%20%28180%29.png)

![Mark word](../../.gitbook/assets/image%20%2891%29.png)

1. 对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ \[数组长（对于数组对象才需要此部分信息）\]
2. 实例数据
3. 对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充。

* 对象头用于存储对象的元数据信息：
  * Mark Word 部分数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值等。Mark Word一般被设计为非固定的数据结构，以便存储更多的数据信息和复用自己的存储空间。
  * 类型指针 指向它的类元数据的指针，用于判断对象属于哪个类的实例。
* 实例数据存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops\(ordinary object pointers\)，相同宽度的字段总是被分配到一起，便于之后取数据。父类定义的变量会出现在子类定义的变量的前面。
* 对齐填充部分仅仅起到占位符的作用，并非必须。

## **2. 对象在虚拟机中的分配过程**

　　\(1\). 检查虚拟机**是否加载了**所要new的类，若没加载，则首先执行相应的类加载过程。虚拟机遇到new指令时，首先去检查这个指令的参数**是否能在常量池中定位到一个类的符号引用**，并且检查这个引用代表的**类是否已经被加载、解析和初始化过**。

　　\(2\). 在类加载检查通过后，对象所需**内存的大小**在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。一般来说，**根据Java堆中内存是否绝对规整，**内存的分配有两种方式：

* **指针碰撞：如果Java堆中内存绝对规整，**所有用过的内存放在一边，空闲内存放在另一边，中间一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相同的距离。
* **空闲列表：如果Java堆中内存并不规整，**那么虚拟机就需要维护一个列表，记录哪些内存块是可用的，以便在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

![](../../.gitbook/assets/image%20%28192%29.png)

　　除了如何划分可用空间之外，还需要考虑**修改指针** \(该指针用于划分内存使用空间和空闲空间\)时的**线程安全问题**，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。解决这个问题有两种方案：

* **对分配内存空间的动作进行同步处理：**采用**CAS+失败重试**的方式保证更新操作的原子性；
* **把内存分配的动作按照线程划分的不同的空间中：**每个线程在Java堆中预先**分配一小块内存**，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的TLAB上分配，如果TLAB用完并分配新的TLAB时，再加同步锁定。

![](../../.gitbook/assets/image%20%28128%29.png)

　　\(3\). 内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值**。如果使用TLAB，也可以提前到TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

　　\(4\). 在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会**执行&lt;init&gt;方法**把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。

## **3. 对象在虚拟机中的访问定位**

　　**创建对象是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象。**在虚拟机规范中，reference类型中只规定了一个指向对象的引用，并没有定义这个引用使用什么方式去定位、访问堆中的对象的具体位置。

目前的主流的访问方式有**使用句柄访问**和**直接指针访问**两种。

* **句柄访问**：Java堆中会划分出一块内存作为句柄池，栈中的reference指向对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。
* **直接指针访问**：reference中存储的就是对象地址。

　　总的来说，这两种对象访问定位方式各有千秋。**使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，reference本身不需要修改；而使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销。**

