# 2.1 Java虚拟机内存模型

        Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域可以分为两个部分：一部分是**线程共享**的，一部分则是**线程私有**的。其中，线程共享的数据区包括**方法区和堆**，线程私有的数据区包括**虚拟机栈、本地方法栈和程序计数器**。如下图所示：

![](../../.gitbook/assets/image%20%2858%29.png)

## **1. 线程私有的数据区**

　　**线程私有的数据区** 包括 程序计数器、 虚拟机栈和本地方法栈 三个区域，它们的内涵分别如下：

### 1\). 程序计数器

　　我们知道，线程是CPU调度的基本单位。在多线程情况下，当线程数超过CPU数量或CPU内核数量时，线程之间就要根据 **时间片轮询**抢夺CPU时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，**为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。**

　　因此，**程序计数器是线程私有的一块较小的内存空间，其可以看做是当前线程所执行的字节码的行号指示器。**如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的字节码指令的地址；如果正在执行的是 Native 方法，则计数器的值为空。

　　程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。

### 2\). 虚拟机栈

　　**虚拟机栈描述的是Java方法执行的内存模型，是线程私有的。**每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且 **每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。**其中，局部变量表主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和 对象句柄，它们可以是方法参数，也可以是方法的局部变量。

　　虚拟机栈有两种异常情况：StackOverflowError 和 OutOfMemoryError。

我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss 参数可以设置虚拟机栈大小），**若线程请求的栈深度大于虚拟机允许的深度，则抛出 StackOverFlowError 异常**。

此外，栈的大小可以是固定的，也可以是动态扩展的，**若虚拟机栈可以动态扩展（大多数虚拟机都可以），但扩展时无法申请到足够的内存\(**比如没有足够的内存为一个新创建的线程分配栈空间时\)，则**抛出 OutofMemoryError 异常**。下图为栈帧结构图：

![](../../.gitbook/assets/image%20%28260%29.png)

### 3\). 本地方法栈

　　**本地方法栈与Java虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。**与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

## **2. 线程共享的数据区**

　　**线程共享的数据区** 具体包括Java堆和方法区两个区域，它们的内涵分别如下：

### 1\). Java 堆

　　**Java 堆的唯一目的就是存放对象实例，几乎所有的对象实例（和数组）都在这里分配内存。**Java堆是线程共享的，类的对象从中分配空间，这些对象通过**new**、**newarray**、 **anewarray** 和 **multianewarray** 等指令建立，它们不需要程序代码来显式的释放。

　　由于Java堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为称为 **GC堆**。**从内存回收的角度看，由于现在的垃圾收集器基本都采用分代收集算法，所以为了方便垃圾回收Java堆还可以分为 新生代** 和 **老年代** 。新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，对象就会被移入老年代。新生代又可进一步细分为 eden、survivorSpace0 和 survivorSpace1。刚创建的对象都放入 eden，s0 和 s1 都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。下图给出了Java堆的结构图：

![](../../.gitbook/assets/image%20%2873%29.png)



**注意，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。**而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx\(最大堆容量\) 和 -Xms\(最小堆容量\)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将**会抛出 OutOfMemoryError 异常**。 

#### \(1\)、TLAB \(Thread Local Allocation Buffer，线程私有分配缓冲区\)

　　Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 TLAB，其大小由JVM根据运行的情况计算而得。在TLAB上分配对象时不需要加锁\(相对于CAS配上失败重试方式 \)，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。

　　在下文中我们提到，虚拟机为新生对象分配内存时，需要考虑修改指针 \(该指针用于划分内存使用空间和空闲空间\) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。**TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。**

### 2\). 方法区

　　**方法区与Java堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的 类信息**、**常量**、**静态变量**、**即时编译器编译后的代码等数据**。方法区通常和永久区\(Perm\)关联在一起，但永久代与方法区不是一个概念，只是有的虚拟机用永久代来实现方法区，这样就可以用永久代GC来管理方法区，省去专门内存管理的工作。根据Java虚拟机规范的规定，当方法区无法满足内存分配的需求时，将抛出 OutOfMemoryError 异常。

#### \(1\)、运行时常量池

　　**运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种 字面量** 和 **符号引用**。其中，字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括以下三类常量：**类和接口的全限定名**、**字段的名称和描述符** 和 **方法的名称和描述符**。因为运行时常量池（Runtime Constant Pool）是方法区的一部分，那么当常量池无法再申请到内存时也会抛出 OutOfMemoryError 异常。

　　**运行时常量池相对于Class文件常量池的一个重要特征是具备动态性。**Java语言并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，比如字符串的**手动入池方法intern\(\)。**

### 3\). Java堆与方法区的区别

　　**Java堆是 Java代码可及的内存，是留给开发人员使用的**；而非堆（Non-Heap）是**JVM留给自己用的**，所以方法区、JVM内部处理或优化所需的内存 \(如JIT编译后的代码缓存\)、每个类结构 \(如运行时常量池、字段和方法数据\)以及**方法**和**构造方法的代码**都在非堆内存中。

### 4\). 方法区的回收

　　方法区的内存回收目标主要是针对 **常量池的回收** 和 **对类型的卸载**。

#### **1. 废弃常量**         

回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是**没有任何String对象引用常量池中的“abc”常量**，**也没有其他地方引用了这个字面量**，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

#### 2. 无用的类

　　类需要同时满足下面3个条件才能算是“无用的类”：

* 该类所有的实例都已经被回收，也就是Java堆中**不存在该类的任何实例**；
* 加载该类的**ClassLoader已经被回收**；
* 该类对应的 j**ava.lang.Class 对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

  　　虚拟机**可以**对满足上述3个条件的无用类进行回收\(卸载\)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

## 3. 堆和栈的区别

### **1. 概括**  

1. **栈是运行时的单位 , 而堆是存储的单元;**
2. **栈解决程序的运行问题，即程序如何执行，或者说如何处理数据，**

    **堆解决的是数据存储的问题，即数据怎么放，放在哪儿**。

###  **2. 堆和栈区分离**

      **总结：**

1. **共享；**
2. **分治；**
3. **动态增长。**

     1. 从**软件设计**的角度看，栈代表了**处理逻辑**，而堆代表了**数据**。这样分开，使得处理逻辑更为清晰。**分而治之**的思想。

     2.堆与栈的分离，使得堆中的内容可以被多个栈**共享**（也可以理解为多个线程访问同一个对象）。

        好处:  a. 提供了一种有效的数据交互方式（如：共享内存）

                   b. 堆中的**共享常量和缓存**可以**被所有栈访问**，节省了空间。

     3. 栈因为**运行时的需要**，比如保存系统运行的上下文，需要**进行地址段的划分**。

        由于**栈只能向上增长**，因此就会限制住**栈存储内容的能力**，

        而堆不同，堆中的对象是可以**根据需要动态增长**的，

        因此栈和堆的拆分使得**动态增长**成为可能，相应栈中只需记录堆中的一个地址即可。

     4. 面向对象就是**堆和栈的完美结合**。

        其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。

        当我们把对象拆开，你会发现，

             **对象的属性其实就是数据，存放在堆中；**

        **而对象的行为（方法），就是运行逻辑，放在栈中。**

        我们在编写对象的时候，其实就是编写了数据结构，也编写了处理数据的逻辑。

###  **3.**  **堆中？栈中？**

      1. 栈存储的信息都是跟当前**线程（或程序）相关的信息**。\(局部变量、程序运行状态、方法、方法返回值\)等，

         栈中存的是**基本数据类型**和**堆中对象的引用**。一个对象的大小是不可估计的，或者说是可以动态变化的，但是**在栈中，一个对象只对应了一个4byte的引用**（堆栈分离的好处）。

     2. 堆只负责存储对象信息。

![&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#x533A;](../../.gitbook/assets/image%20%28157%29.png)

###  **3：基本类型放堆中呢？**

     ****1. 其占用的空间一般是1~8个字节---**需要空间比较少**，

     2.而且因为是基本类型，所以不会出现动态增长的情况---**长度固定**，因此栈中存储就够了，如果把它存在堆中是没有什么意义的。

      数据类型是放在栈中还是放在堆中，这取决于类型在何处声明，下面对数据类型在内存中的存储问题来解释一下：

### 1. 在方法中声明的变量

     该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个**方法栈**，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因：

（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中

（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。

### 2. 在类中声明的变量

       是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）:

       （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的

       （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。

