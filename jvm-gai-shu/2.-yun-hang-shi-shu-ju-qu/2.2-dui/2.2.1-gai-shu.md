# 2.2.1 概述

## 一、简介

　　对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。　　  
　　Java把内存分成两种：栈内存和堆内存。简单的来讲，堆内存用于存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。而栈内存由使用的人向系统申请，申请人进行管理。

## 二、堆的结构

分代的内存管理，分成：新生代、老年代和永久代（1.8中无永久代，使用metaspace实现）三块区域。

![](https://images2017.cnblogs.com/blog/285763/201708/285763-20170804154957194-1883454534.png)

**堆**被划分成两个不同的区域：**新生代** \( Young \)、**老年代** \( Old \)。**新生代** \( Young \) 又被划分为三个区域：Eden、From Survivor、To Survivor。如下：

* **Eden区**：新对象或者生命周期很短的对象会存储在这个区域中，这个区的大小可以通过-XX:NewSize和-XX:MaxNewSize参数来调整。新生代GC（垃圾回收器）会清理这一区域。
* **Survivor区**：两个幸存区，那些历经了Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域。这个区的大小可以由JVM参数-XX:SurvivorRatio来进行调节。
* **老年代**：新对象会首先分配在Eden中（如果对象过大，比如大数组，将会直接放到老年代）。在GC中，Eden中的对象会被移动到survivor中，直至对象满足一定的年纪（定义为熬过minor GC的次数），会被移动到老年代。年老代中的对象的回收是由老年代的GC（major GC）来进行的。

这样划分的目的是为了使 JVM 能够更好的**管理堆内存中的对象，包括内存的分配以及回收**。

## 三、对象分配规则

* **对象优先分配在Eden区**，如果Eden区没有足够的空间时，虚拟机执行一次**Minor GC**。
* **大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
* **长期存活的对象进入老年代**。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
* **动态判断对象的年龄**。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
* **空间分配担保**。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

数组的内部表示  
　　在Java中，**数组是真正的对象**。和其他对象一样，数组总是存储在堆中。同样，数组也拥有一个与它们的类相关联的Class实例，**所有具有相同维度和类型的数组都是同一个类的实例**，**而不管数组的长度（多维数组每一维的长度）是多少**。例如一个包含3个int整数的数组和一个包含300个整数的数组拥有同一个类。**数组的长度只与实例数据有关**。  
　　**数组类的名称**由两部分组成：**每一维用一个方括号“\[”表示**，**用字符或字符串表示元素类型**。比如，元素类型为int整数的、一维数组的类名为“\[I”，元素类型为byte的三维数组为“\[\[\[B”，元素类型为Object的二维数组为“\[\[Ljava/lang/Object”。  
　　**多维数组被表示为数组的数组**。比如，int类型的二维数组，将表示为一个一维数组，其中的每一个元素是一个一维int数组的引用，如下图：

![](https://images2017.cnblogs.com/blog/285763/201708/285763-20170804155158069-1186775138.png)

在堆中的每个数组对象还必须保存的数据时数组的长度、数组数据，以及某些指向数组的类数据的引用。虚拟机必须能够通过一个数组对象的引用得到此数组的长度，通过索引访问其元素（期间要检查数组边界是否越界），调用所有数组的直接超类Object声明的方法等等。

## 四、JVM对堆的管理/设置

#### 默认分配比例：

Eden : from : to = 8 : 1 : 1 \( 可以通过参数 –XX:SurvivorRatio 来设定 \)，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。  
新生代 \( Young \) 与老年代 \( Old \) 的比例的值为 1:2 \( 该值可以通过参数–XX:NewRatio来指定 \)

#### Total Heap：

-Xms ：指定了JVM初始启动以后初始化内存  
-Xmx：指定JVM堆得最大内存，在JVM启动以后，会分配-Xmx参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存

#### New Generation\(新生代\)：

**1\)-XX:NewSize和-XX:MaxNewSize（jdk1.3or1.4）**

用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。

例如：-XX:NewRatio=8意味着tenured和young的比值8：1，这样eden+2\*survivor=1/9

**2\)-Xmn（jdk1.4or lator）**

用于设置年轻代大小。例如：-Xmn10m，设置新生代大小为10m。此处的大小是（eden+ 2 survivor space\).与jmap -heap中显示的New gen是（eden+1 survivor space）不同的。

#### Perm Generation：

-XX:PermSize=16M -XX:MaxPermSize=64M

#### 栈：

Thread Stack  
-XX:Xss=128K

## 五、堆的垃圾回收

Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：

Minor GC、Full GC \( 或称为 Major GC \)。  
**Minor GC** 是发生在新生代中的垃圾收集动作，所采用的是**复制算法**。  
新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。  
当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。  
当对象在 Eden \( 包括一个 Survivor 区域，这里假设是 from 区域 \) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳  
\( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 \)，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 \( 即 to 区域 \) 中，然后清理所使用过的 Eden 以及 Survivor 区域 \( 即 from 区域 \)，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 \( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 \)，这些对象就会成为老年代。  
但这也不是一定的，对于一些较大的对象 \( 即需要分配一块较大的连续内存空间 \) 则是直接进入到老年代。  
**Full GC** 是发生在老年代的垃圾收集动作，所采用的是**标记-清除算法**。  
现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代\(Old\)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。  
另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 \( 即不连续的内存空间 \)，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

