# 3.1.2 对象分配

![](../../../.gitbook/assets/image%20%2871%29.png)

### **1.  为什么会有年轻代**

         **优化GC性能**。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

### 2. 年轻代GC

HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区\(一些大对象特殊处理\),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。

因为年轻代中的对象基本都是朝生夕死的\(80%以上\)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值\(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置\)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

![](../../../.gitbook/assets/image%20%2836%29.png)

### 3. 一个对象的内存分配过程

       我是一个普通的[Java](http://lib.csdn.net/base/17)对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年\(每次GC加一岁\)，然后被回收。

### 4. 何时进入老生代

对象内存主要分配在新生代**Eden区**, 如果启用了本地线程分配缓冲, 则**优先在TLAB上分配**, 少数情况能会直接分配在老年代, 或被拆分成标量类型在栈上分配\(JIT优化\). 分配的规则并不是百分百固定, 细节主要取决于垃圾收集器组合, 以及VM内存相关的参数.

#### 1.对象分配

* 优先在Eden区分配 新生代堆内存可以划分为一块Eden区和两块Survivor区. 在大多数情况下, 对象在新生代Eden区中分配, 当Eden区没有足够空间分配时, VM发起一次Minor GC, 将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域, 如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区, 则会通过**空间分配担保机制**使对象提前进入老年代\(空间分配担保见下\).
* 大对象直接进入老年代 Serial和ParNew两款收集器提供了**-XX:PretenureSizeThreshold**的参数, 令大于该值的大对象直接在老年代分配, 这样做的目的是**避免在Eden区和Survivor区之间产生大量的内存复制**\(大对象一般指 _需要大量连续内存的Java对象_, 如很长的字符串和数组\), 因此大对象容易导致_**还有不少空闲内存就提前触发GC以获取足够的连续空间**_.

#### 2. 对象晋升

* 年龄阈值 VM为每个对象定义了一个对象年龄\(Age\)计数器, 对象在Eden出生如果**经第一次Minor GC后仍然存活, 且能被Survivor容纳的话**, 将被移动到Survivor空间中, 并将**年龄设为1**. 以后**对象在Survivor区中每熬过一次Minor GC年龄就+1**. 当增加到一定程度\(**-XX:MaxTenuringThreshold**, 默认15\), 将会晋升到老年代.
* 提前晋升: 动态年龄判定 然而VM并不总是要求对象的年龄必须达到**MaxTenuringThreshold**才能晋升老年代: _**如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代**_, 而无须等到晋升年龄.

### 5. 空间分配担保

     在发生Minor GC时，虚拟机会检查老年代连续的空闲区域是否大于新生代所有对象的总和，若成立，则说明Minor GC是安全的，否则，虚拟机需要查看HandlePromotionFailure的值，看是否运行担保失败，若允许，则虚拟机继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，将尝试进行一次Minor GC；若小于或者HandlePromotionFailure设置不运行冒险，那么此时将改成一次Full GC，以上是JDK Update 24之前的策略，之后的策略改变了，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

　　冒险是指经过一次Minor GC后有大量对象存活，而新生代的survivor区很小，放不下这些大量存活的对象，所以需要老年代进行分配担保，把survivor区无法容纳的对象直接进入老年代。

![](../../../.gitbook/assets/image%20%2869%29.png)

  


![](../../../.gitbook/assets/image%20%2843%29.png)

