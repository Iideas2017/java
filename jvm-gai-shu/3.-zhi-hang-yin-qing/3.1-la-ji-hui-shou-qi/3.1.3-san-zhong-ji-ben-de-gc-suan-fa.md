# 3.1.3 三种基本的GC算法

### **1.  标记／清除算法**

内存中的对象构成一棵树，当有效的内存被耗尽的时候，程序就会停止，做两件事，第一：标记，标记从树根可达的对象（图中水红色），第二：清除（清楚不可达的对象）。标记清除的时候有**停止程序运行**，如果不停止，此时如果存在新产生的对象，这个对象是树根可达的，但是没有被标记（标记已经完成了），会清除掉。

缺点：递归效率低性能低；释放空间不连续容易导致内存碎片；会停止整个程序运行；

![&#x6807;&#x8BB0;&#xFF0F;&#x6E05;&#x9664;&#x7B97;&#x6CD5;](../../../.gitbook/assets/image%20%2822%29.png)

### **2.  复制算法**

把内存分成两块区域：空闲区域和活动区域，第一还是标记（标记谁是可达的对象），标记之后把可达的对象复制到空闲区，将空闲区变成活动区，同时把以前活动区对象1，4清除掉，变成空闲区。

速度快但耗费空间，假定活动区域全部是活动对象，这个时候进行交换的时候就相当于多占用了一倍空间，但是没啥用。

![&#x590D;&#x5236;&#x7B97;&#x6CD5;](../../../.gitbook/assets/image%20%2837%29.png)

### **3.  标记整理算法**

平衡点

标记谁是活跃对象，整理，会把内存对象整理成一课树一个连续的空间，

![](../../../.gitbook/assets/image%20%2853%29.png)

### **4. JVM垃圾回收分代收集算法**

综合了上述算法优略

1， 分代GC在**新生代**的算法：采用了GC的**复制**算法，速度快，因为新生代一般是新对象，都是瞬态的用了可能很快被释放的对象。

2， 分代GC在年老代的算法 **标记／整理**算法，GC后会执行压缩，整理到一个连续的空间，这样就维护着下一次分配对象的指针，下一次对象分配就可以采用碰撞指针技术，将新对象分配在第一个空闲的区域。

