# 3.1.4 JVM垃圾回收器

#### 1. **垃圾收集器组合**

![&#x5783;&#x573E;&#x6536;&#x96C6;&#x5668;&#x7EC4;&#x5408;](../../../.gitbook/assets/image%20%28108%29.png)

![](../../../.gitbook/assets/image%20%2818%29.png)

![](../../../.gitbook/assets/image%20%28115%29.png)

![](../../../.gitbook/assets/image%20%2886%29.png)

![](../../../.gitbook/assets/image%20%28139%29.png)

![](../../../.gitbook/assets/image%20%28114%29.png)

![](../../../.gitbook/assets/image%20%28138%29.png)

**（A）、并行与并发**

      能充分利用多CPU、多核环境下的硬件优势；

      可以并行来缩短"Stop The World"停顿时间；

      也可以并发让垃圾收集与用户程序同时进行；

**（B）、分代收集，收集范围包括新生代和老年代**    

      能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；

      能够采用不同方式处理不同时期的对象；

      虽然保留分代概念，但Java堆的内存布局有很大差别；

      将整个堆划分为多个大小相等的独立区域（Region）；

      新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；

**（C）、结合多种垃圾收集算法，空间整合，不产生碎片**

      从整体看，是基于标记-整理算法；

      从局部（两个Region间）看，是基于复制算法；

      这是一种类似火车算法的实现；

      都不会产生内存碎片，有利于长时间运行；

**（D）、可预测的停顿：低停顿的同时实现高吞吐量**

      G1除了追求低停顿处，还能建立可预测的停顿时间模型；

      可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；

