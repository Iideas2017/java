# 3.1.1 java 对象存活分析

 **如何判断一个对象是否应该被回收**

### 1. **引用计数法**

     逻辑是：在堆中存储对象时，在**对象头处维护一个counter计数器**，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter- -。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。

#### 问题：

1.  软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。
2. 如果一个对象A持有对象B，而对象B也持有一个对象A，那发生了类似操作系统中死锁的循环持有，这种情况下A与B的counter恒大于1，会使得GC永远无法回收这两个对象。

### **2. 可达性分析算法**

     通过一系列名为**GC Roots**的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**\(Reference Chain\)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

一般来说，如下情况的对象可以作为**GC Roots**：

1. 虚拟机栈\(**栈桢中的本地变量表**\)中的引用的对象
2. 方法区中的**类静态属性**引用的对象
3. 方法区中的**常量引用**的对象
4. 本地方法栈中**JNI（Native方法）**的引用的对象

### 3. HotSpot虚拟机如何实现可达性算法

 **1. 使用OopMap记录并枚举根节点**

 HotSpot首先需要枚举所有的GC Roots根节点，虚拟机栈的空间不大，遍历一次的时间或许可以接受，但是方法区的空间很可能就有数百兆，遍历一次需要很久。更加关键的是，当我们遍历所有GC Roots根节点时，我们需要暂停所有用户线程，因为我们需要一个此时此刻的”虚拟机快照”，如果我们不暂停用户线程，那么虚拟机仍处于运行状态，我们无法确保能够正确遍历所有的根节点。所以此时的时间开销过大更是我们不能接受的。

 **HotSpot实现了一种叫做OopMap的数据结构，这种数据结构在类加载完成时把对象内的偏移量是什么类型计算出，并且存放下位置，当需要遍历根结点时访问所有OopMap即可。**

2.  **用安全点Safepoint约束根节点**

如果将每个符合GC Roots条件的对象都存放进入OopMap中，那么OopMap也会变得很大，而且其中很多对象很可能会发生一些变化，这些变化使得维护这个映射表很困难。实际上，HotSpot并没有为每一个对象都创建OopMap，只在特定的位置上创建了这些信息，这些位置称为**安全点**（Safepoints）。

为了保证虚拟机中安全点的个数不算太多也不是太少，主要决定安全点是否被建立的因素是时间。当进行了耗时的操作时，比如方法调用、循环跳转等时会产生安全点。此外，HotSpot虚拟机在安全点的基础上还增加了安全区域的概念，安全区域是安全点的扩展。在一段安全区域中能够实现安全点不能达成的效果。

