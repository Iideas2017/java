# 3.2.1 解析

## 1. 符号引用

        在程序运行时，进行**方法调用**是最普遍、最频繁的操作，但是Class文件的编译过程不包括传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是**符号引用**，而不是方法在实际运行时内存布局中的**入口地址**（相对于之前说的**直接引用**）。这个特性给Java带来了更强大的**动态扩展能力**，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。 

根据定义：符号引用属于编译原理方面的概念，包括了下面三类常量：

* 类和接口的全限定名
* 字段的名称和描述符
* 方法的名称和描述符

## 2. 直接引用

 直接引用有两种方式来定位对象，句柄和直接指针。看下面的图加深下理解：

![](../../../.gitbook/assets/image%20%2851%29.png)

虚拟机栈里面 reference 可以理解成直接引用，换句话说，直接引用 存储 在虚拟机栈中（并不是说，其它地方就不能存储直接引用了）。

从这里也可以映证一点：在内存分配与回收过程中，判断对象是否可达的可达性分析算法中：可作为**GC roots 的对象**有**：虚拟机栈中引用的对象**。

![](../../../.gitbook/assets/image%20%28286%29.png)

## 2. 解析

        所有方法调用中的目标方法在Class文件里面都是一个常量池中的**符号引用**，在类加载的解析阶段，会将其中的一部分符号引用转化为**直接引用**，这种解析能成立的前提是：

       方法在程序真正运行之前就有一个**可确定的调用版本**，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为**解析**（Resolution）。

       所有方法调用中的目标方法在Class文件里面都是一个**常量池**中的引用，在类加载的解析阶段，会将其中的一部分**符号引用转化为直接引用**。这种解析能成立的前提是：方法在程序真正执行之前就有一个**可确定的调用版本**，并且这个方法的调用版本在**运行期是不可改变的**。换句话说，调用目标在**程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析。**

        在Java语言中符合“**编译期可知，运行期不可变**”这个要求的方法，主要包括**静态方法和私有方法两大类**，**前者与类型直接关联，后者在外部不可被访问**，这两种方法各自的特点决定了它们都**不可能通过继承或别的方式重写其他版本**，因此它们都适合在**类加载阶段进行解析。**

与之相对应的是，在Java虚拟机里面提供了**5条方法调用字节码指令**，分别如下。

* invokestatic：      调用**静态**方法。
* invokespecial：   调用**实例**构造器＜init＞方法、**私有**方法和**父类**方法。
* invokevirtual：     调用所有的**虚方法**。
* invokeinterface： 调用接口方法，会在运行时再确定一个实现此接口的对象。
* invokedynamic： 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而**invokedynamic**指令的分派逻辑是由用户所设定的引导方法决定的。

         只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有**静态方法、私有方法、实例构造器、父类方法4类**，它们在类加载的时候就会把**符号引用解析为该方法的直接引用**。这些方法可以称为**非虚方法**，与之相反，其他方法称为虚方法（除去final方法）。

       Java中的非虚方法除了**使用invokestatic、invokespecial调用的方法**之外还有一种，就是**被final修饰的方法**。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了**final方法是一种非虚方法**。

