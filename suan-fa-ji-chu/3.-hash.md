# 3. Hash

## 1. 基础

###  1.1 概念        

              **散列表**,又叫**哈希表**，它是基于**快速存取**的角度设计的，也是一种典型的“**空间换时间**”的做法。顾名思义，该数据结构可以理解为一个**线性表**，但是其中的**元素不是紧密排列**的，而是**可能存在空隙**。

### 1.2 思考

1. **快速存取**： 基于一种**结果尽可能随机平均分布**的固定**函数H**为**每个元素安排存储位置**，这样就可以**避免遍历性质的线性搜索**，**以达到快速存取；**
2. **冲突**： 即**两个元素通过散列函数H得到的地址相同**，那么这两个元素称为“同义词”；
3. **冲突原因：**    
      （1）散列函数是否均匀；

      （2）处理冲突的方法；

      （3）散列表的装填因子，太大浪费空间（ **装填因子**定义为：**α= 填入表中的元素个数 / 散列表的长度），** α与“填入表中的元素个数”成正比，所以，**α越大，填入表中的元素较多，产生冲突的可能性就越大，所以扩容**；**α越小，填入表中的元素较少，产生冲突的可能性就越小**。

4.  实际上，散列表的**平均查找长度**是装填因子**α的函数**，只是不同处理冲突的方法有不同的函数。

### 1.3 查找性能分析

         散列表的查找过程基本上和造表过程相同：

1. **不冲突**的：可通过散列函数转换的地址**直接找到；**
2. **冲突**的：    按处理冲突的方法进行查找；在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是**给定值与关键码进行比较的过程**。所以，对散列表查找效率的量度，依然用**平均查找长度**来衡量。

## 2. Hash函数

           散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位：

　　**1. 直接寻址法：**取**关键字**或**关键字的某个线性函数值**为散列地址。即**H\(key\)=key**或**H\(key\) = a?key + b**，其中a和b为常数（这种散列函数叫做**自身函数**）

　　**2. 数字分析法：**分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相 同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会 明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。

　　**3. 平方取中法：**取**关键字平方后的中间几位**作为散列地址。

　　**4. 折叠法：**将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。

　　**5. 随机数法：**选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。

　　**6. 除留余数法：**取关键字被某个**不大于散列表表长m的数p**除后所得的余数为散列地址。即 **H\(key\) = key MOD p**, p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。

## 3.碰撞解决

### 3.1 开放地址法（再散列法）



![](../.gitbook/assets/image%20%28181%29.png)

其中，**增量di有三种取法：**

1. **线性探测再散列   di = 1 , 2 , 3 , ... , m-1**  （冲突发生时，**顺序查看表中下一单元**，直到找出一个空单元或查遍全表）
2. **平方探测再散列   di = 1 , -1, 2 , -2,  4 , -4 , 9 , -9 , ... ,**  $$k ^ 2$$ **,  -**$$k ^ 2$$（ 冲突发生时，在**表的左右进行跳跃式探测**，比较灵活。）
3. **随机探测再散列   di 是一组伪随机数列**

### 3.2 再hash法

        就是**算hashcode的方法不止一个**，**一个要是算出来重复啦，再用另一个算法去算，**直到不重复为止咯；

同时构造多个不同的哈希函数：

        **Hi=RH1（key）  i=1，2，…，k**

当**哈希地址Hi=RH1（key）发生冲突**时，**再计算Hi=RH2（key）……，直到冲突不再产生**。这种方法**不易产生聚集**，但**增加了计算时间**。

![](../.gitbook/assets/image%20%28139%29.png)

### 3.3 链地址法

          将所有哈希地址为i的元素构成一个**单链表**，并将单链表的头指针存在哈希表的第i个单元中，链地址法适用于经常进行**插入和删除**的情况。

###  3.4 建立公共溢出区

        将哈希表分为**基本表和溢出表**两部分，凡是和**基本表发生冲突**的元素，一律**填入溢出表**。

### 3.5 优缺点

#### 开放散列（open hashing）/ 拉链法（针对桶链结构）

1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③**删除记录时，比较方便**，直接通过指针操作即可 

2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录**不容易进行序列化（serialize）**操作

#### 封闭散列（closed hashing）/ 开放定址法

1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的

 2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。

## 4.Hash算法在Java中的应用

###       4.1哈希算法在HashMap类中的应用

         java中的集合，比如HashMap/Hashtable/HashSet等，在实现时，都用到了哈希算法。当我们向容器中添加元素时，我们有必要知道这个元素是否已经存在。

1. 调用hashcode\(\)方法，判断元素A在容器中是否已经存在，不存在，则直接插入；
2. 存在，调用equals\(\)方法，判断A元素在容器中是否已经存在
3. hashcode\(\)的时间复杂度为O\(1\)equals\(\)方法的时间复杂度为O\(m\)，整体的时间复杂度就是：O\(1\) + O\(m\)。其中，m是桶的深度。桶的深度是指**具有相同hashcode值的元素的个数**，也就是发生哈希碰撞的元素的个数。

###       4.2 哈希算法在String类中的应用

          Sring类中的hash算法是： **乘加迭代运算，详见String.hashCode（）源码。**



