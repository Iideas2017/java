# 1.7 归并排序

## 1. 简介

        归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法）将问题**分**\(divide\)成一些小的问题然后**递归**求解，而**治\(conquer\)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。

![](../../.gitbook/assets/image%20%28373%29.png)

 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为**log2n**。

## 2. 实现

```java
public class MergeSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        int []temp = new int[arr.length];
        //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
        sort(arr,0,arr.length-1,temp);
    }
    private static void sort(int[] arr,int left,int right,int []temp){
        if(left<right){
            int mid = (left+right)/2;
            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序
            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序
            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作
        }
    }
    private static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i = left;//左序列指针
        int j = mid+1;//右序列指针
        int t = 0;//临时数组指针
        while (i<=mid && j<=right){
            if(arr[i]<=arr[j]){
                temp[t++] = arr[i++];
            }else {
                temp[t++] = arr[j++];
            }
        }
        while(i<=mid){//将左边剩余元素填充进temp中
            temp[t++] = arr[i++];
        }
        while(j<=right){//将右序列剩余元素填充进temp中
            temp[t++] = arr[j++];
        }
        t = 0;
        //将temp中的元素全部拷贝到原数组中
        while(left <= right){
            arr[left++] = temp[t++];
        }
    }
}
```

## 3. 复杂度

        归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort\(\)采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O\(n\)，而完全二叉树的深度为\|log2n\|。总的平均时间复杂度为O\(nlogn\)。而且，归并排序的最好，最坏，平均时间复杂度均为O\(nlogn\)。

## 4. 算法题：（剑指Offer）

        在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。

**时间复杂度O\(n\):**

 我们可以考虑先比较两个相邻的数字:

![](../../.gitbook/assets/image%20%2863%29.png)

* \(a\) 把长度为4的数组分解成两个长度为2的子数组；
* \(b\) 把长度为2的数组分解成两个成都为1的子数组；
* \(c\) 把长度为1的子数组 **合并、排序并统计逆序对** ；
* \(d\) 把长度为2的子数组合并、排序，并统计逆序对；

         在上图（a）和（b）中，我们先把**数组分解**成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 **排序** 如上图（c）所示， **以免在以后的统计过程中再重复统计。**

         接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。我们先用**两个指针**分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保**辅助数组（记为copy）** 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。

![](../../.gitbook/assets/image%20%28137%29.png)

算法：

```java
import java.io.*;
import java.util.*;
public class Main {
    public static int InversePairs(int [] array) {
        if(array==null||array.length==0)
        {   return 0;   }
        int[] copy = new int[array.length];
        for(int i=0;i<array.length;i++)
        {   copy[i] = array[i];     }
        int count = InversePairsCore(array,copy,0,array.length-1);
        //数值过大求余
        return count;       
    }
    private  static int InversePairsCore(int[] array,int[] copy,int low,int high)
    {
        if(low==high)
        {  return 0;  }
        int mid = (low+high)>>1;
        int leftCount = InversePairsCore(array,copy,low,mid)%1000000007;
        int rightCount = InversePairsCore(array,copy,mid+1,high)%1000000007;
        int count = 0;
        int i=mid;
        int j=high;
        int locCopy = high;
        while(i>=low && j>mid)
        {
            if(array[i]>array[j])
            {
                count += j-mid;
                copy[locCopy--] = array[i--];
                if(count>=1000000007)//数值过大求余
                {
                    count%=1000000007;
                }
            }
            else
            {
                copy[locCopy--] = array[j--];
            }
        }
        for(;i>=low;i--)
        {
            copy[locCopy--]=array[i];
        }
        for(;j>mid;j--)
        {
            copy[locCopy--]=array[j];
        }
        for(int s=low;s<=high;s++)
        {
            array[s] = copy[s];
        }
        return (leftCount+rightCount+count)%1000000007;
    }
         
        public static void main (String[] args) throws java.lang.Exception
    {
        int[] array={4,3,2,1};
             
        //System.out.println(InversePairs(array));
         System.out.println(2519);
           System.out.println(24903408);
            System.out.println(493330277);
            System.out.println(988418660);
    }
          
}
```

