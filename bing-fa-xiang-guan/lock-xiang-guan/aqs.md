# 2.3 AQS

## 1. AQS工作原理概要

       内部通过一个int类型的成员变量state来控制同步状态,当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作;

同时利用内部类ConditionObject构建等待队列，当Condition调用wait\(\)方法后，线程将会加入等待队列中，

而当Condition调用signal\(\)方法后，线程将从等待队列转移动同步队列中进行锁竞争。

注意这里涉及到两种队列，一种的**同步队列**，当线程**请求锁而等待的**后将加入同步队列等待，而另一种则是**等待队列\(**可有多个\)，通过Condition调用await\(\)方法释放锁后，将加入等待队列。

## 2. AQS的模板方法设计模式

       它的**子类必须重写AQS的几个protected修饰的用来改变同步状态的方法**，其他方法主要是实现了排队和阻塞机制。

       **状态的更新使用getState, setState 以及compareAndSetState 这三个方法**。

![AQS&#x53EF;&#x91CD;&#x5199;&#x7684;&#x65B9;&#x6CD5;](../../.gitbook/assets/image%20%28162%29.png)

![AQS&#x63D0;&#x4F9B;&#x7684;&#x6A21;&#x677F;&#x65B9;&#x6CD5;](../../.gitbook/assets/image%20%2891%29.png)

AQS提供的模板方法可以分为3类：

1. 独占式获取与释放同步状态；
2. 共享式获取与释放同步状态；
3. 查询同步队列中等待线程情况；

同步组件通过AQS提供的模板方法实现自己的同步语义。

## 3. 同步队列

 获取锁失败进行入队操作，获取锁成功进行出队操作

![&#x540C;&#x6B65;&#x961F;&#x5217;&#x6A21;&#x578B;](../../.gitbook/assets/image%20%2889%29.png)

* 其中head指向同步队列的头部，注意**head为空结点**，不存储信息。而tail则是同步队列的队尾，同步队列采用的是**双向链表**的结构这样可方便队列**进行结点增删操作**。
* **state**变量则是代表**同步**状态，执行当线程调用lock方法进行加锁后，如果此时state的值为0，则说明当前线程可以获取到锁\(在本篇文章中，锁和同步状态代表同一个意思\)，同时将state设置为1，表示获取成功。如果state已为1，也就是当前锁已被其他线程持有，那么当前执行线程将被封装为Node结点加入同步队列等待。
* 其中**Node结点**是对每一个访问同步代码的线程的封装，从图中的Node的数据结构也可看出，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，**Node是AQS的内部类**。

### 3.1  独占式锁的获取

![](../../.gitbook/assets/image%20%28135%29.png)

![](../../.gitbook/assets/image%20%28101%29.png)

### 3.2 独占锁的释放

 首先获取头节点的后继节点，当后继节点的时候会调用LookSupport.unpark\(\)方法，该方法会唤醒该节点的后继节点所包装的线程。因此，**每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。**

### **3.3 总结**

1. **线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter\(\)和enq\(\)，同时enq\(\)完成对同步队列的头结点初始化工作以及CAS操作失败的重试**;
2. **线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park\(\)方法使得线程阻塞**；
3. **释放锁的时候会唤醒后继节点。**

 **在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor\(\)方法唤醒后继节点。**

## 4. 等待队列

![&#x7B49;&#x5F85;&#x961F;&#x5217;](../../.gitbook/assets/image%20%2810%29.png)

**等待队列是一个单向队列;**

 **不带头结点的链式队列;**

 **对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列**。

 当当前线程调用condition.await\(\)方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理。

