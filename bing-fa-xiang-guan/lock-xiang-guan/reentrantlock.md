# 2.4 ReentrantLock

##  1. ReentrantLock的介绍

        **** 1. 重入性的实现原理；2. 公平锁和非公平锁。

## 2. 重入性的实现原理

 **1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；**

 **2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。**

## 3. 公平锁与公平锁

 **公平锁**和**非公平锁**。**何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO**。

1. 公平锁每次获取到锁为同步队列中的第一个节点，**保证请求资源时间上的绝对顺序**，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，**造成“饥饿”现象**。
2. 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock**默认选择的是非公平锁**，则是为了减少一部分上下文切换，**保证了系统更大的吞吐量**。

  
  


