# 1.5 Synchronized 关键字

## 1. synchronized使用场景

![synchronized&#x5B9E;&#x73B0;&#x539F;&#x7406;](../../.gitbook/assets/image%20%2877%29.png)

**如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系**。

## 2. synchronized实现原理

### 2.1 对象锁（monitor）机制

1. 执行同步代码块后首先要先执行**monitorenter**指令，退出的时候**monitorexit**指令；
2.  这就是**锁的重入性**，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized先天具有重入性。**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。即，重入锁只有**monitorexit。**

       任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到**BLOCKED状态。**

![&#x5BF9;&#x8C61;&#xFF0C;&#x5BF9;&#x8C61;&#x76D1;&#x89C6;&#x5668;&#xFF0C;&#x540C;&#x6B65;&#x961F;&#x5217;&#x548C;&#x7EBF;&#x7A0B;&#x72B6;&#x6001;&#x7684;&#x5173;&#x7CFB;](../../.gitbook/assets/image%20%2879%29.png)

        该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。

### 2.2 synchronized的happens-before关系

 **监视器锁规则**：对同一个监视器的解锁，happens-before于对该监视器的加锁。

### 2.3 锁获取和锁释放的内存语义

 线程A通过主内存中的共享变量和线程B进行通信，A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。

## 3. synchronized优化

### 3.1 CAS操作

#### 3.1.1 什么是CAS?

使用锁时，线程获取锁是一种**悲观锁策略**，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作（又称为无锁操作）是一种**乐观锁策略**，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用**CAS\(compare and swap\)**又叫做比较交换来鉴别线程是否出现冲突，**出现冲突就重试**当前操作直到没有冲突为止。

### 3.1.2 CAS的操作过程

CAS比较交换的过程可以通俗的理解为CAS\(V,O,N\)，包含三个值分别为：**V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值**。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。

###  3.1.3 Synchronized VS CAS

元老级的Synchronized\(未优化前\)最主要的问题是：在存在线程竞争的情况下会出现线程**阻塞和唤醒锁带来的性能**问题，因为这是一种互斥同步（**阻塞同步**）。而CAS并不是武断的将线程挂起，当CAS**操作失败后会进行一定的尝试**，而**非进行耗时的挂起唤醒的操作**，因此也叫做**非阻塞同步**。这是两者主要的区别。

### 3.1.4 CAS的应用场景

在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现。

### 3.1.5 CAS的问题

**1. ABA问题**  
 因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。java这么优秀的语言，当然在java 1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题，解决思路就是这样的。

**2. 自旋时间过长**

使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的**pause指令**，那么在效率上会有一定的提升。

**3. 只能保证一个共享变量的原子操作**

当对一个共享变量执行操作时CAS能保证其原子性，如果**对多个共享变量进行操作,CAS就不能保证其原子性**。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。

### 3.2 Java对象头

在同步的时候是获取对象的monitor,即获取到对象的锁。那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位。32为JVM Mark Word默认存储结构为

![Mark Word&#x5B58;&#x50A8;&#x7ED3;&#x6784;](../../.gitbook/assets/image%20%2885%29.png)

![Mark Word&#x72B6;&#x6001;&#x53D8;&#x5316;](../../.gitbook/assets/image%20%281%29.png)

 这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

### 3.3 偏向锁

HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

> **偏向锁的获取**

当一个线程访问同步块并获取锁时，会在**对象头**和**栈帧中的锁记录**里存储锁偏向的线程ID，以后该线程在进入和退出同步块时**不需要进行CAS操作来加锁和解锁**，只需简单地测试一下对象头的**Mark Word里是否存储着指向当前线程的偏向锁**。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

> **偏向锁的撤销**

偏向锁使用了一种**等到竞争出现才释放锁**的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

![&#x504F;&#x5411;&#x9501;&#x64A4;&#x9500;&#x6D41;&#x7A0B;](../../.gitbook/assets/image%20%2820%29.png)

 如图，偏向锁的撤销，需要等待**全局安全点**（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word**要么**重新偏向于其他线程，**要么**恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

下图线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程。

![&#x504F;&#x5411;&#x9501;&#x83B7;&#x53D6;&#x548C;&#x64A4;&#x9500;&#x6D41;&#x7A0B;](../../.gitbook/assets/image%20%28107%29.png)

> **如何关闭偏向锁**

偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：**-XX:BiasedLockingStartupDelay=0**。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：**-XX:-UseBiasedLocking=false**，那么程序默认会进入轻量级锁状态

### 3.4 轻量级锁

> **加锁**

线程在执行同步块之前，JVM会先在当前**线程的栈桢中创建用于存储锁记录的空间**，并将对象头中的Mark Word复制到锁记录中，官方称为**Displaced Mark Word**。然后线程尝试使用CAS**将对象头中的Mark Word替换为指向锁记录的指针**。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

> **解锁**

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。

![&#x8F7B;&#x91CF;&#x7EA7;&#x9501;&#x52A0;&#x9501;&#x89E3;&#x9501;&#x4EE5;&#x53CA;&#x9501;&#x81A8;&#x80C0;](../../.gitbook/assets/image%20%2848%29.png)

        因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

### 3.5 各种锁的比较

![&#x5404;&#x79CD;&#x9501;&#x7684;&#x6BD4;&#x8F83;](../../.gitbook/assets/image%20%28111%29.png)



