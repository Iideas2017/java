# 1.4 volatile 变量

##  1.概述

         **被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。**

## 2. volatile实现原理

 生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出**Lock前缀的指令：**

1. 将当前处理器缓存行的数据**写回系统内存**；
2. 这个写回内存的操作会使得**其他CPU里缓存了**该内存地址的数据**无效。**

       就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

## 3. volatile的happens-before关系

       **volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。**

## 4. volatile的内存语义

 线程A和线程B之间进行了一次通信，线程A在写volatile变量时，实际上就像是给B发送了一个消息告诉线程B你现在的值都是旧的了，然后线程B读这个volatile变量时就像是接收了线程A刚刚发送的消息。

### 4.1 volatile的内存语义实现

        我们都知道，为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。

![&#x5185;&#x5B58;&#x5C4F;&#x969C;&#x5206;&#x7C7B;&#x8868;](../../.gitbook/assets/image%20%2861%29.png)

![volatile&#x91CD;&#x6392;&#x5E8F;&#x89C4;&#x5219;&#x8868;](../../.gitbook/assets/image%20%28150%29.png)

保守策略：

1. 在每个volatile写操作的**前面**插入一个StoreStore屏障；
2. 在每个volatile写操作的**后面**插入一个StoreLoad屏障；
3. 在每个volatile读操作的**后面**插入一个LoadLoad屏障；
4. 在每个volatile读操作的**后面**插入一个LoadStore屏障。

需要注意的是：volatile写是在前面和后面**分别插入内存屏障**，而volatile读操作是在**后面插入两个内存屏障**

**StoreStore屏障**：禁止上面的普通写和下面的volatile写重排序；

**StoreLoad屏障**：防止上面的volatile写与下面可能有的volatile读/写重排序

**LoadLoad屏障**：禁止下面所有的普通读操作和上面的volatile读重排序

**LoadStore屏障**：禁止下面所有的普通写操作和上面的volatile读重排序  
  
  


