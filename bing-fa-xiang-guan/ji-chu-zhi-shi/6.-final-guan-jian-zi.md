# 1.6 final关键字

## 1. final的简介

        final可以修饰**变量，方法和类**，用于表示所修饰的内容一旦赋值之后就不会再被改变，比如String类就是一个final类型的类。

## 2. final的具体使用场景

### 2.1 变量

在java中变量，可以分为**成员变量**以及方法**局部变量**。

#### 2.1.1 final成员变量

通常每个类中的**成员变量**可以分为**类变量（static修饰的变量）以及实例变量**。

1. **类变量**：必须要在**静态初始化块**中指定初始值或者**声明该类变量时**指定初始值，而且只能在这**两个地方**之一进行指定；
2. **实例变量**：必要要在**非静态初始化块**，**声明该实例变量**或者在**构造器中**指定初始值，而且只能在这**三个地方**进行指定。

当final变量未初始化时系统不会进行隐式初始化，会出现报错。

#### 2.2.2 final局部变量

**final局部变量**由程序员进行**显式初始化**，如果final局部变量已经进行了初始化则后面就不能再次进行更改，如果final变量未进行初始化，可以进行赋值，**当且仅有一次**赋值，一旦赋值之后再次赋值就会出错。

#### 2.2.3   **final基本数据类型 VS  final引用数据类型**

* **基本数据类型变量**，**不能对基本数据类型变量重新赋值**，因此基本数据类型变量不能被改变;
* **引用类型变量**，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个**对象属性是可以改变的。**

#### 2.2.4 **宏变量**

1. 使用final修饰符修饰；
2. 在定义该final变量时就指定了初始值；
3. 该初始值在**编译时就能够唯一指定**。

注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值。

### 2.2 方法

禁止该方法在子类中被覆盖，类的private方法会**隐式地被指定为final方法**

#### 2.2.1 **重写**

 当父类的方法被final修饰的时候，子类不能重写父类的该方法。

#### 2.2.2 **重载**

 可以重载的

### 2.3 类

**当一个类被final修饰时，表明该类是不能被子类继承的**，类中的**所有成员方法**都会被**隐式**地指定为final方法。

## 3. final的例子

###  3.1 不变类

 八个包装类和String类都是不可变类

1. **final 类**；
2. 成员变量 **private final** 且无**setter**方法；
3. **带参构造器**初始化成员变量**，进行深拷贝（deep copy）；** 
4.  **在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝；**
5. 如果有必要，**重写hashCode和equals方法**，同时应保证两个用equals方法判断为相等的对象，其hashCode也应相等。

###  3.2 深拷贝、浅拷贝

#### 3.2.1 浅拷贝

 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。

如果属性是**基本类型**，拷贝的就是基本类型的值；

如果属性是**内存地址**（引用类型），拷贝的就是**内存地址** ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

![&#x6D45;&#x62F7;&#x8D1D;](../../.gitbook/assets/image%20%28105%29.png)

 实现对象拷贝的类，必须实现**Cloneable接口**，并覆写**clone\(\)方法**。

#### 3.2.2 深拷贝

      深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。

![&#x6DF1;&#x62F7;&#x8D1D;](../../.gitbook/assets/image%20%2813%29.png)

## 4. 多线程中final

     **编译器和处理器重排序**

###  final域重排序规则

基本数据类型:

1. final域写：禁止**final域写**与**构造方法**重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。
2. final域读：禁止初次**读对象的引用**与**读该对象包含的final域**的重排序。

引用数据类型：

额外增加约束：禁止在构造函数对**一个final修饰的对象的成员域的写入**与随后将**这个被构造的对象的引用赋值给引用变量** 重排序。 

## 5.final的实现原理

    写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。  
  
 **以X86为例的话，对final域的读/写的内存屏障都会被省略**！

## 6. 为什么final引用不能从构造函数中“溢出”

 **在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“逸出”**。

