# 1.5.1 Synchronized 关键字

## 1. synchronized使用场景

![synchronized&#x5B9E;&#x73B0;&#x539F;&#x7406;](../../../.gitbook/assets/image%20%28298%29.png)

**如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系**。

## 2. synchronized实现原理

### 2.1 对象锁（monitor）机制

1. 执行同步代码块后首先要先执行**monitorenter**指令，退出的时候**monitorexit**指令；
2.  这就是**锁的重入性**，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized先天具有重入性。**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。即，重入锁只有**monitorexit。**

       任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到**BLOCKED状态。**

![&#x5BF9;&#x8C61;&#xFF0C;&#x5BF9;&#x8C61;&#x76D1;&#x89C6;&#x5668;&#xFF0C;&#x540C;&#x6B65;&#x961F;&#x5217;&#x548C;&#x7EBF;&#x7A0B;&#x72B6;&#x6001;&#x7684;&#x5173;&#x7CFB;](../../../.gitbook/assets/image%20%28313%29.png)

        该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。

### 2.2 synchronized的happens-before关系

 **监视器锁规则**：对同一个监视器的解锁，happens-before于对该监视器的加锁。

### 2.3 锁获取和锁释放的内存语义

 线程A通过主内存中的共享变量和线程B进行通信，A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。

## 

