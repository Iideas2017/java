# 1.1 线程的状态转换

## 1. 创建线程

 实际上java程序天生就是一个多线程程序，包含了：

1. 分发处理发送给给JVM信号的线程；
2. 调用对象的finalize方法的线程；
3. 清除Reference的线程；
4. main线程，用户程序的入口。

 新建一个线程了，只有三种方式：

1. 通过继承**Thread**类，重写**run**方法；
2. 通过实现**runable**接口；
3. 通过实现**callable**接口。

## 2. 线程状态转换

![&#x7EBF;&#x7A0B;&#x72B6;&#x6001;&#x8F6C;&#x6362;](../../.gitbook/assets/image%20%28334%29.png)

1. 线程创建之后调用start\(\)方法开始运行,进入到 **New**状态**；**
2. 当调用wait\(\), join\(\), LockSupport.lock\(\)方法线程会进入到**WAITING**状态；
3. wait\(long timeout\), sleep\(long\), join\(long\), LockSupport.parkNanos\(\), LockSupport.parkUtil\(\) 增加了**超时等待**的功能，也就是调用这些方法后线程会进入**TIMED\_WAITING**状态；
4. 当超时等待时间到达后，线程会切换到**Runable**的状态；当**WAITING**和**TIMED \_WAITING**状态时可以通过Object.notify\(\),Object.notifyAll\(\)方法使线程转换到**Runable**状态。
5. 当线程出现资源竞争时，即等待获取锁的时候，线程会进入到**BLOCKED**阻塞状态，当线程获取锁时，线程进入到**Runable**状态。
6. 线程运行结束后，线程进入到**TERMINATED**状态，状态转换可以说是线程的生命周期。
7. 当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是**BLOCKED**状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是**WAITING**或者**TIMED\_WAITING**状态，因为lock会调用**LockSupport**的方法。

![JAVA&#x7EBF;&#x7A0B;&#x7684;&#x72B6;&#x6001;](../../.gitbook/assets/image%20%2814%29.png)

## 3. 线程状态的基本操作

         除了新建一个线程外，线程在生命周期内还有需要基本操作，而这些操作会成为线程间一种通信方式，比如使用中断（interrupted）方式通知实现线程间的交互等等

### 3.1 interrupted 静态方法

中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用**该线程的interrupt\(\)方法**对其进行中断操作，同时该线程可以调用 isInterrupted（）来感知其他线程对其自身的中断操作，从而做出响应。

同样可以调用Thread的**静态方法interrupted（）**对当前线程进行中断操作，该方法会清除中断标志位。**需要注意的是，当抛出InterruptedException时候，会清除中断标志位，也就是说在调用isInterrupted会返回false。**

 中断操作可以看做线程间一种简便的交互方式。一般在**结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。**

### 3.2 join  非静态方法

join方法可以看做是线程间协作的一种方式

### 3.3 sleep 静态方法

public static native void sleep\(long millis\)方法显然是Thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。

需要注意的是如果当前线程获得了锁，sleep方法**并不会失去锁**。

> **sleep\(\) VS wait\(\)**

两者主要的区别：

1. sleep\(\)方法是Thread的**静态方法**，而wait是**Object实例方法;**
2. wait\(\)方法必须要在**同步方法或者同步块中调用**，也就是**必须已经获得对象锁**。而sleep\(\)方法没有这个限制可以在任何地方种使用。另外，**wait\(\)方法会释放占有的对象锁**，使得该线程进入等待池中，等待下一次获取资源。而sleep\(\)方法  **VBN BVCXVBN MBVCGBFRVNH HBGVFCD** ；
3. sleep\(\)方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait\(\)方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。

### 3.4 yield 静态方法

public static native void yield\(\);   一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配**给当前线程相同优先级**的线程。

 **线程优先级：**

        现代操作系统基本采用**时分**的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。

        在Java程序中，通过一个**整型成员变量Priority**来控制优先级，优先级的范围从1~10.在构建线程的时候可以通过**setPriority\(int\)**方法进行设置，默认优先级为5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同JVM以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。

       **sleep\(\)**和**yield\(\)**方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep\(\)**交出来的时间片其他线程都可以去竞争**，也就是说都有机会获得当前线程让出的时间片。而**yield\(\)方法只允许与当前线程具有相同优先级的线程**能够获得释放出来的CPU时间片。  


## 4. 守护线程Daemon

        守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，**JIT线程**就可以理解**守护线程**。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。  
  
      **守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的。**

线程可以通过**setDaemon\(true\)**的方法将线程设置为守护线程。

并且需要注意的是设置守护线程要**先于start\(\)**方法。

