# 1.死锁

## 1. 死锁的产生

        线程死锁是指由于**两个或者多个线程互相持有对方所需要的资源**，**导致这些线程处于等待状态，无法前往执行**。当线程进入对象的**synchronized**代码块时，便占有了资源，直到它退出该代码块或者调用**wait方法**，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。

### 版本 1：

**当然死锁的产生是必须要满足一些特定条件的：**   
1. **互斥条件**：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放   
2. **请求和保持条件**：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。   
3. **不剥夺条件**：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用   
4. **循环等待条件**：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

### 版本 2：

1. **互斥：**至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一进程申请该资源，那么申请进程必须等到该资源被释放为止。
2. **占有并等待：**一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。
3. **非抢占：**资源不能被抢占，即资源只能在进程完成任务后自动释放。
4. **循环等待：**有一组等待进程{P0，P1，···，Pn}，P0等待的资源为P1所占有，P1等待的资源为P2所占有，...，Pn-1等待的资源为Pn所占有，Pn等待的资源为P0所占有。

　　注：强调所有4个条件必须同时满足才会出现死锁。循环等待意味着占有并等待，这样四个条件并不完全独立。

### **资源分配图**

　　死锁问题可用**系统资源分配图**的有向图进行更为精确的描述。这种图由一个结点集合V和一个边集合E组成。

　　由进程Pi到资源类型Rj的有向边记为**Pi-&gt;Rj，称为申请边**，它表示进程Pi已经申请了资源类型Rj的一个实例，并在等待该资源。由资源类型Rj到进程Pi的有向边记为**Rj-&gt;Pi，称为分配边**，它表示资源类型Rj的一个实例已经分配给进程Pi。

　　在图上，用**圆形**表示**进程Pi**，用**矩形**表示**资源类型Rj**。由于资源类型Rj可能有多个**实例**，所以在矩形中用**圆点**表示实例。注意申请边只指向矩形Rj，而分配边必须指定矩形内的某个圆点。

　　根据分配图的定义，可以证明：**如果分配图没有环，那么系统就没有进程死锁，如果分配图有环，那么可能存在死锁。**

![&#x5B58;&#x5728;&#x6B7B;&#x9501;&#x7684;&#x8D44;&#x6E90;&#x5206;&#x914D;&#x56FE;        &#x5B58;&#x5728;&#x73AF;&#x4F46;&#x6CA1;&#x6709;&#x6B7B;&#x9501;&#x7684;&#x8D44;&#x6E90;&#x5206;&#x914D;&#x56FE;](../.gitbook/assets/image%20%2873%29.png)

由上图可知，资源分配图有环不一定会产生死锁。

### **死锁处理方法**

* 可使用协议以预防或避免死锁，确保系统不会进入死锁状态。
* 可允许系统进入死锁状态，然后检测它，并加以恢复。
* 可忽视这个问题，认为死锁不可能在系统内发生。

### **死锁预防**

我们已经知道，出现死锁要满足4个必要条件，只要确保一个必要条件不成立，就能预防死锁发生。下面通过讨论这4个必要条件来研究死锁预防方法。

**互斥：**                 共享资源不是必须的，而非共享资源必须保持互斥  
**占有并等待：**    必须保证进程申请资源的时候没有占有其他资源  
　　·要求进程在执行前一次申请全部的资源，只有没有占有资源时才可以分配资源  
　　·利用率低，可能出现饥饿  
**非抢占：**如果一个进程的申请没有实现，它要释放所有占有的资源  
**循环等待：**将所有的资源类型放入资源列表中，并且要求进程按照资源表中递增的顺序申请资源

### **死锁避免**

　　上面我们讨论的死锁预防算法中，通过限制资源申请的方法来预防思索。这种限制确保4个必要条件之一不会发生，因此死锁不成立。然而，通过**这种方法预防死锁的副作用是低设备使用率和系统吞吐率。**

**·安全状态**

## 2. 银行家算法



