# JVM对字符串变量的处理

### **1）String，不可变的字符串**

```java
String javaStr = new String("小学徒的成长历程");
```

        **这条语句创建了两个字符串对象**：一个是“小学徒的成长历程”这个**直接量对应的字符串对象**，一个是由new String\(\)构造器返回的**字符串对象**。

       对于Java程序中的字符直接量（eg：String javaStr = "小学徒的成长历程_**"**_），JVM会使用一个字符串池来保存他们，**当第一次使用某个字符串直接量时，JVM会将它放入字符串池进行缓存**。当程序再次需要使用该字符串时，无须重新创建一个新的字符串，而是直接引用变量执行字符串中已有的字符串。

       但是对于使用构造器进行初始化的字符串（eg :String javaStr = new String\("小学徒的成长历程"\)），因为**凡是通过构造器创建的对象都会进行内存分配**，所以他就不会指向缓存池中已有的对象而指向新的对象。

```java
 String javaStr = "小学徒" + "的" + "成长历程";
```

        **总共创建了一个对象；**因为如果一个字符串连接表达式的值可以在编译时确定下来，那么JVM会在编译时计算该字符串变量的值，并让他指向字符串池中对应的字符串。但如果程序**使用了变量，或者调用了方法**，那么就只能等到运行时才可确定该字符串连接式的值，也就无法在编译时确定字符串变量的值，因此无法确定该字符串变量的值，所以无法利用JVM的字符串池。

```java
String name = "小学徒";  name = name + "的成长空间";
```

         **两条语句总共创建了3个字符串对象：**一个是“小学徒”,一个是"的成长空间"，这两个是存在与缓存池中的，还有一个是"小学徒的成长历程"，这个是在**运行时期**确定的，不会缓存于缓冲区。

         **java为了节省内存，提高资源的复用，才引入了字符串缓存池的概念，而且，在缓存池中的字符串是不会被垃圾回收机制回收的，基本都是常驻内存，所以过多使用String类，可能会出现内存溢出**。

对String对象进行操作后，其返回的是一个新的对象，之前那个对象是没有改变的，改变的是name这个引用所指的对象，这时候的对象已经是新的对象，然而之前那个对象被废弃了，但是他存在缓存池，因此不会被垃圾回收机制回收，所以这里会容易出现内存泄漏，所以如果要操作字符串，尽量不用String而改为使用StringBuffer或者StringBuilder。

###  2 **StringBuilder和StringBuffer: 可变的字符串**

  StringBuilder和StringBuffer在进行字符串操作的时候就不会去创建一个新出现的对象，引用的都是同一个对象，减少了String带来的弊端。

