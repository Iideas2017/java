# BIO、NIO、AIO

## 1. 基础

| **名词** | **解释** | **举例** |
| :--- | :--- | :--- |
| 同步 | 用户进程触发IO操作并**等待或者轮询**的去查看IO操作是否就绪 | 自己上街买衣服，自己亲自干这件事，别的事干不了。 |
| 异步 | 用户进程触发IO操作以后便**开始做自己的事情**，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是**通知**） | 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS） |
| 阻塞 | 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入**等待状态**, 直到有东西可读或者可写为止 | 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。） |
| 非阻塞 | 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 | 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。 |

 1 **同步和异步**是针对**应用程序和内核的交互**而言的。

 同步/异步是在时间上**强调处理事情的结果/机会成本**的两种处理策略：         

         **强调结果**意味着对结果的迫不急待，不过结果是正确的还是错误的，反正你要立即给我一个结果响应；                                                                                                                                     

        **强调时间机会成本**意味着对等待结果浪费的时间极其难接受，而对结果并不是那么急切，暂时不管结果（让处理方处理完主动通知结果/自己空闲的时候主动去获取结果）转而去处理其他事情

2 **同步/异步**是宏观上（**进程间通讯**，通常表现为**网络IO**的处理上），阻塞/非阻塞是微观上（**进程内数据传输**，通常表现为**对本地IO的处理上**）；**阻塞和非阻塞是同步/异步的表现形式**

3 **阻塞和非阻塞**是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种**读取或者写入操作函数的实现方式**，阻塞方式下读取或者写入函数将**一直等待**，而非阻塞方式下，读取或者写入函数会立即**返回一个状态值**。

由上描述基本可以总结一句简短的话，同步和异步是**目的**，阻塞和非阻塞是**实现方式**。 

## 2. 定义

**BIO**：**同步阻塞**，每一个**socket套接字**需要使用**一个线程**来处理。建立连接、进行读写操作的时候都可能阻塞。在服务器端如果要支持并发的连接时，需要更多的线程。连接不做任何事情的时候会造成不必要的线程开销，可通过线程池来改善。

![BIO](../../../.gitbook/assets/image%20%2872%29.png)

**NIO** ： **同步非阻塞**，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

![](../../../.gitbook/assets/image%20%2876%29.png)

**AIO** ： **异步非阻塞**，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， NIO方式适用于**连接数目多且连接比较短**（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于**连接数目多且连接比较长**（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持 I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。另外NIO的非阻塞，需要一直轮询，也是一个比较耗资源的。

![](../../../.gitbook/assets/image%20%28104%29.png)

## 3. 比较

![](../../../.gitbook/assets/image%20%2852%29.png)

