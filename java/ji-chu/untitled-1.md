# 1.2 基本数据和引用数据

Java中的数据类型分两种：基本数据类型和引用数据类型。

![](../../.gitbook/assets/image%20%28135%29.png)

## 1. **基本数据类型** （8种）

对于这些都是用的_==_来比较两者的值是不是相等。（byte short int long char float double boolean）

* 在Java中有八种基本数据类型：

  　　浮点型：float\(4 byte\), double\(8 byte\)

  　　整型：byte\(1 byte\), short\(2 byte\), int\(4 byte\) , long\(8 byte\)

  　　字符型: char\(2 byte\)

  　　布尔型: boolean\(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”\)

* 要注意的是，**浮点型和整型都是有符号类型的（最高位仅用于表示正负，不参与计算【以 byte 为例，其范围为 -2^7 ~ 2^7 - 1，-0即-128】），而char是无符号类型的（所有位均参与计算，所以char类型取值范围为0~2^16-1）**。

###   flaot的存储示意图

  _**sign 代表符号位 1 代表负数 0代表正数；    exponent  代表指数位  最大为127 ，和byte有一点点联系   其中第30位（0代表指数为 1 为正）；**_

_**fraction 代表小数位，共有23位实际上表示24位，第24位唯一 是1  ，所以表示的小数就是  1.   ..........**_

                                       **31                       30                  29----23               22----0**         

                        **表示实数符号位        指数符号位           指数位             有效数位\(就是科学记数法的前面的那个有小数点的数\)**

### 将一个float型转化为内存存储格式的步骤为：

     **（1）先将这个实数的绝对值化为二进制格式，注意实数的整数部分和小数部分的二进制方法在上面已经探讨过了。   
     （2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。   
     （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。   
     （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。   
     （5）如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。   
     （6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。**

          举例说明： 11.9的内存存储格式

       \(1\) 将11.9化为二进制后大约是" 1011. 1110011001100110011001100..."。

       \(2\) 将小数点左移三位到第一个有效位右侧： "1. 011 11100110011001100110 "。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。

       \(3\) 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011 11100110011001100110 ”共23bit。将它放入float存储结构的第22到第0位。

       \(4\) 因为11.9是正数，因此在第31位实数符号位放入“0”。

       \(5\) 由于我们把小数点左移，因此在第30位指数符号位放入“1”。

       \(6\) 因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。

           最后表示11.9为：  ****_**0**_ ****_**1**_ ****_**0000010**_ ****_**011**_ ****_**11100110011001100110**_

           再举一个例子：0.2356的内存存储格式  
      （1）将0.2356化为二进制后大约是0.00111100010100000100100000。   
      （2）将小数点右移三位得到1.11100010100000100100000。   
      （3）从小数点右边数出二十三位有效数字，即11100010100000100100000放  
入第22到第0位。   
      （4）由于0.2356是正的，所以在第31位放入“0”。   
      （5）由于我们把小数点右移了，所以在第30位放入“0”。   
      （6）因为小数点被右移了3位，所以将3化为二进制，在左边补“0”补足七  
位，得到0000011，各位取反，得到1111100，放入第29到第23位。   
       __

           最后表示0.2356为：   _**0** **0** **1111100** 11100010100000100100000_

 

## 2.  引用数据类型

           一般情况下，equals和==是一样的都是比较的两者的地址值是不是一样。但是有特殊的情况：我们都知道我们使用的类都是继承自Object基类，Object中equals方法中是使用==来实现的，即比较的是两者的地址值。但是Object的子类可以重写equals方法，比如Date、String、Integer等类都是重写了equals都是重写了，比较的是值是否相等。例如String类的源码：

{% page-ref page="../1.-string/string-yuan-ma-xue-xi.md" %}

## 3. 存储位置

      数据类型是放在栈中还是放在堆中，这取决于类型在何处声明，下面对数据类型在内存中的存储问题来解释一下：

### 1. 在方法中声明的变量

     该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个**方法栈**，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因：

（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中

（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。

### 2. 在类中声明的变量

       是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）:

       （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的

       （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中

