# 2.2 IOC 初始化

       IoC容器的初始化包括BeanDefinition的Resource**定位、载入和注册**这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext系列容器也许是我们最熟悉的，因为web项目中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext等，其继承体系如下图所示：

![](../../.gitbook/assets/image%20%2816%29.png)

 ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。

##  1. XmlBeanFactory的整个流程

```java
public class XmlBeanFactory extends DefaultListableBeanFactory{
     private final XmlBeanDefinitionReader reader; 
     public XmlBeanFactory(Resource resource)throws BeansException{
         this(resource, null);
     }
     public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory)
          throws BeansException{
         super(parentBeanFactory);
         this.reader = new XmlBeanDefinitionReader(this);
         this.reader.loadBeanDefinitions(resource);
    }
 }
```

```java
//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息
 ClassPathResource resource =new ClassPathResource("application-context.xml");
//创建DefaultListableBeanFactory
 DefaultListableBeanFactory factory =new DefaultListableBeanFactory();
//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory
 XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);
//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用
 reader.loadBeanDefinitions(resource);
```

 通过前面的源码，this.reader = new **XmlBeanDefinitionReader**\(this\); 中其中this 传的是factory对象。

##  2. FileSystemXmlApplicationContext 的IOC容器流程

```java
ApplicationContext =new FileSystemXmlApplicationContext(xmlPath);
```

### 2.1  构造函数

```java
public FileSystemXmlApplicationContext(String... configLocations) 
throws BeansException {
        this(configLocations, true, null);
    }
```

```java
public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)  
            throws BeansException {    
        super(parent);  
        setConfigLocations(configLocations);  
        if (refresh) {  
            refresh();  
        }  
    } 
```

#### 1. 设置资源加载器

首先，调用父类容器的构造方法\(super\(parent\)方法\)为容器**设置好Bean资源加载器**。

 通过追踪FileSystemXmlApplicationContext的继承体系，发现其**父类的父类**AbstractApplicationContext中初始化IoC容器所做的主要源码如下：

```java
public abstract class AbstractApplicationContext extends DefaultResourceLoader  
        implements ConfigurableApplicationContext, DisposableBean {  
    //静态初始化块，在整个容器创建过程中只执行一次  
    static {  
        //为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容  
       //器关闭事件(ContextClosedEvent)类  
        ContextClosedEvent.class.getName();  
    }  
    //FileSystemXmlApplicationContext调用父类构造方法调用的就是该方法  
    public AbstractApplicationContext(ApplicationContext parent) {  
        this.parent = parent;  
        this.resourcePatternResolver = getResourcePatternResolver();  
    }  
    //获取一个Spring Source的加载器用于读入Spring Bean定义资源文件  
    protected ResourcePatternResolver getResourcePatternResolver() {  
        // AbstractApplicationContext继承DefaultResourceLoader，也是一个S  
        //Spring资源加载器，其getResource(String location)方法用于载入资源  
        return new PathMatchingResourcePatternResolver(this);  
    }   
……  
} 
```

 构造方法中调用PathMatchingResourcePatternResolver的构造方法创建Spring资源加载器：

```java
public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {  
        Assert.notNull(resourceLoader, "ResourceLoader must not be null");  
        //设置Spring的资源加载器  
        this.resourceLoader = resourceLoader;  
} 
```

 然后，再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations\(configLocations\)方法设置Bean定义资源文件的定位路径。

#### 2.资源文件定位

在设置容器的资源加载器之后，接下来FileSystemXmlApplicationContet执行**setConfigLocations**方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean定义资源文件的定位，该方法的源码如下：

```java
//处理单个资源文件路径为一个字符串的情况  
    public void setConfigLocation(String location) {  
       //String CONFIG_LOCATION_DELIMITERS = ",; /t/n";  
       //即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式  
        setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));  
    }  

    //解析Bean定义资源文件的路径，处理多个资源文件字符串数组  
     public void setConfigLocations(String[] locations) {  
        if (locations != null) {  
            Assert.noNullElements(locations, "Config locations must not be null");  
            this.configLocations = new String[locations.length];  
            for (int i = 0; i < locations.length; i++) {  
                // resolvePath为同一个类中将字符串解析为路径的方法  
                this.configLocations[i] = resolvePath(locations[i]).trim();  
            }  
        }  
        else {  
            this.configLocations = null;  
        }  
    } 
```

通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean定义资源文件，也可以使用字符串数组，即下面两种方式都是可以的：

a.    ClasspathResource res = new ClasspathResource\(“a.xml,b.xml,……”\);

多个资源文件路径之间可以是用” ,; /t/n”等分隔。

b.    ClasspathResource res = new ClasspathResource\(newString\[\]{“a.xml”,”b.xml”,……}\);

至此，Spring IoC容器在初始化时将配置的Bean定义资源文件定位为Spring封装的Resource。

####  3. 载入Bean定义

     Spring IoC容器对Bean定义资源的载入是从**refresh\(\)函数**开始的，refresh\(\)是一个模板方法，refresh\(\)方法的作用是：**在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭**，**以保证在refresh之后使用的是新建立起来的IoC容器**。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入.

FileSystemXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh\(\)函数启动整个IoC容器对Bean定义的载入过程：

```java
public void refresh() throws BeansException, IllegalStateException {  
        synchronized (this.startupShutdownMonitor) {  
            //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  
            prepareRefresh();  
            //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从  
           //子类的refreshBeanFactory()方法启动  
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  
            //为BeanFactory配置容器特性，例如类加载器、事件处理器等  
            prepareBeanFactory(beanFactory);  
            try {  
                //为容器的某些子类指定特殊的BeanPost事件处理器  
                postProcessBeanFactory(beanFactory);  
                //调用所有注册的BeanFactoryPostProcessor的Bean  
                invokeBeanFactoryPostProcessors(beanFactory);  
                //为BeanFactory注册BeanPost事件处理器.  
                //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件  
                registerBeanPostProcessors(beanFactory);  
                //初始化信息源，和国际化相关.  
                initMessageSource();  
                //初始化容器事件传播器.  
                initApplicationEventMulticaster();  
                //调用子类的某些特殊Bean初始化方法  
                onRefresh();  
                //为事件传播器注册事件监听器.  
                registerListeners();  
                //初始化所有剩余的单态Bean.  
                finishBeanFactoryInitialization(beanFactory);  
                //初始化容器的生命周期事件处理器，并发布容器的生命周期事件  
                finishRefresh();  
            }  
            catch (BeansException ex) {  
                //销毁以创建的单态Bean  
                destroyBeans();  
                //取消refresh操作，重置容器的同步标识.  
                cancelRefresh(ex);  
                throw ex;  
            }  
        }  
    }
```

refresh\(\)方法主要为IoC容器Bean的生命周期管理提供条件，Spring IoC容器载入Bean定义资源文件从其**子类容器的refreshBeanFactory\(\)方法**启动，所以整个refresh\(\)中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory\(\);”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。

AbstractApplicationContext的obtainFreshBeanFactory\(\)方法调用子类容器的refreshBeanFactory\(\)方法，启动容器载入Bean定义资源文件的过程，代码如下：

```java
 protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {  
        //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
         refreshBeanFactory();  
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();  
        if (logger.isDebugEnabled()) {  
            logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);  
        }  
        return beanFactory;  
    } 
```

AbstractApplicationContext子类的refreshBeanFactory\(\)方法：

   AbstractApplicationContext类中只抽象定义了refreshBeanFactory\(\)方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的    refreshBeanFactory\(\)方法，方法的源码如下：

```java
protected final void refreshBeanFactory() throws BeansException {  
       if (hasBeanFactory()) {//如果已经有容器，销毁容器中的bean，关闭容器  
           destroyBeans();  
           closeBeanFactory();  
       }  
       try {  
            //创建IoC容器  
            DefaultListableBeanFactory beanFactory = createBeanFactory();  
            beanFactory.setSerializationId(getId());  
           //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等  
           customizeBeanFactory(beanFactory);  
           //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  
           loadBeanDefinitions(beanFactory);  
           synchronized (this.beanFactoryMonitor) {  
               this.beanFactory = beanFactory;  
           }  
       }  
       catch (IOException ex) {  
           throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);  
       }  
   }
```

在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions\(beanFactory\)装载bean定义。

