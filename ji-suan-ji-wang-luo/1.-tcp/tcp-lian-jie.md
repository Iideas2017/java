# 2.1 TCP 连接

## 1. TCP

![&#x62A5;&#x6587;&#x683C;&#x5F0F;](../../.gitbook/assets/image%20%285%29.png)

上图中有几个字段需要重点介绍下：

1. **序号**：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. **确认序号**：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
3. **标志**位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
   1. URG：紧急指针（urgent pointer）有效。
   2. ACK：确认序号有效。
   3. PSH：接收方应该尽快将这个报文交给应用层。
   4. RST：重置连接。
   5. SYN：发起一个新连接。
   6. FIN：释放一个连接。

 需要注意的是：

（A）不要将确认序号Ack与标志位中的ACK搞混了。

（B）确认方Ack=发起方Req+1，两端配对。 

## 2. 三次握手

\(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功\)：

* **第一次握手：**Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN\_SENT状态，等待Server确认。
* **第二次握手：**Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN\_RCVD状态。
* **第三次握手：**Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![](../../.gitbook/assets/image%20%2829%29.png)

## 3. 四次挥手

\(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧\)：

* 第一次挥手：Client发送一个FIN，**用来关闭Client到Server的数据传送**，Client进入FIN\_WAIT\_1状态。
* 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE\_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
* 第三次挥手：Server发送一个FIN，**用来关闭Server到Client的数据传送**，Server进入LAST\_ACK状态。
* 第四次挥手：Client收到FIN后，Client进入TIME\_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

![](../../.gitbook/assets/image%20%28379%29.png)

## 4. 深度解析

### 1.为什么三次握手？

**为什么TCP链接需要三次握手，两次不可以么，为什么？**

　　为了防止 **已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

### 2. 为什么三次？四次？

     这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把**ACK和SYN放在一个报文里**发送给客户端。

     而关闭连接时，当收到对方的FIN报文时，仅仅表示**对方不再发送数据了但是还能接收数据**，**己方也未必全部数据都发送给对方了**，所以**己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接**，因此，己方ACK和FIN一般都会分开发送。

### 3. 为什么2MSL？

       网络是不可靠的，有可能最后一个ACK丢失。所以TIME\_WAIT状态就是用来重发可能丢失的ACK报文。

### 4. DDOS?

**客户端不断进行请求链接会怎样？DDos\(Distributed Denial of Service\)攻击？**

　　服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

1\)、DDos 攻击

* 客户端向服务端**发送请求链接数据包**
* 服务端向客户端发送确认数据包
* 客户端**不向服务端发送确认数据包**，服务器一直等待来自客户端的确认

2\)、DDos 预防 

**\( 没有彻底根治的办法，除非不使用TCP \)**

* 限制同时打开SYN半链接的数目
* 缩短SYN半链接的Time out 时间
* 关闭不必要的服务

