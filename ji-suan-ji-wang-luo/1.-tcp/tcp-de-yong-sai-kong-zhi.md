# 2.2 TCP 的拥塞控制

## **1.  TCP的流量控制——滑动窗口**

### **1.1  流量控制概述**

       如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。

       ****TCP采用**大小可变**的**滑动窗口**进行流量控制，窗口大小的**单位是字节**。发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，**随时动态地调整对方的发送窗口上限值\(可增大或减小\)**。

        为什么要设置窗口？我们可以把窗口理解为**缓冲区**（但是有些窗口和缓冲区又不太一样）。**如果没有这些“窗口”，那么TCP每发送一段数据后都必须等到接收端确认后才能发送下一段数据，这样做的话TCP传输的效率实在是太低了**。解决的办法就是**在发送端等待确认的时候继续发送数据**，假设发送到第X个数据段是收到接收端的确认信息，如果X在可接受的范围内那么这样做也是可接受的。这就是窗口（缓冲区）引入的缘由。

（1）接收端窗口 rwnd    ****

 **接收端缓冲区大小**。接收端将此窗口值**放在 TCP 报文的首部中的窗口字段**，传送给发送端。

（2）拥塞窗口 cwnd \(congestion windo**w\)**    **发送端缓冲区大小**

（3）发送窗口swnd             

           发送窗口的上限值 = Min \[rwnd, cwnd\]，当 rwnd &lt; cwnd 时，是接收端的接收能力限制发送窗口的最大值。当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。 

（4） 滑动窗口

        发送端已发送了 400 字节的数据，但只收到对前 200 字节数据的确认，同时窗口大小不变。还可发送 300 字节。

        发送端收到了对方对前 400 字节数据的确认，但对方通知发送端必须把窗口减小到 400 字节。现在发送端最多还可发送 400 字节的数据。

        TCP的流量控制是利用**滑动窗口机制**实现的，接收方在**返回的ACK中会包含自己的接收窗口的大小**，以**控制发送方的数据发送**。

![](../../.gitbook/assets/image%20%28387%29.png)

###  **1.2  流量控制实例**

![](../../.gitbook/assets/image%20%28110%29.png)

 如上图所示A向B发送数据。在连接建立时，B告诉A接收窗口rwnd（receiver window）= 400，单位字节，因此发送方A的发送窗口不能400。

（可以看出，B向A发送的三个报文段都设置了 ACK = 1以保证字段有效，后面的rwnd值就是接收方对发送方的三次流量控制。）

第一次把窗口设置为300 ，第二次100 ，最后一次为 0，即不允许发送方再发送数据的状态。

但是当某个ACK报文丢失了，就会出现A等待B确认，并且B等待A发送数据的死锁状态。为了解决这种问题，TCP引入了持续计时器（Persistence timer），当A收到rwnd=0时，就启用该计时器，时间到了则发送一个1字节的探测报文，询问B是很忙还是上个ACK丢失了，然后B回应自身的接收窗口大小，返回仍为0（A重设持续计时器继续等待）或者会重发rwnd=x。

##  **2. TCP的拥塞控制**

### **2.1 拥塞控制概述**

        我们仍然需要理解为什么需要拥塞控制。网络中的链路容量、交换结点中的缓存、处理机等等都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。**拥塞控制就是防止过多的数据注入到网络中**，这样可以**使网络中的路由器或链路不致过载**。

### **2.2** **慢开始（Slow-Start）和拥塞避免（Congestion Avoidance）结合**

在这种机制中，发送方维护一个叫做**拥塞窗口**的变量，只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的数据发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的数据。

#### **2.2.1** **两种算法机制介绍**

**慢开始算法**是指开始发送数据时，并不清楚网络的负荷情况，会先发送一个1字节的试探报文，当收到确认后，就发送2个字节的报文，继而4个，8个以此指数类推。

需要注意的是，慢开始的“慢”并不是指拥塞窗口的增长速率慢，而是指在TCP开始发送报文时先设置拥塞窗口=1。

**拥塞避免算法**是让拥塞窗口缓慢地增大，即cwnd加1，而不是如慢开始算法一样加倍。

**2.2.2** **两种算法的结合的实例分析**

![](../../.gitbook/assets/image%20%28286%29.png)

根据上图的实例进行分析，一开始的慢开始算法的指数增长是很恐怖的，所以为了防止拥塞窗口cwnd增长过快需要设置一个门限ssthresh，这里是16。

1. 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。
2. 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
3. 当 cwnd = ssthresh 时，既可使用**慢开始算法**，也**可使用拥塞控制避免算法**。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方没有收到确认，就认为这时候拥塞了，就要把慢开始门限**ssthresh设置为此时发送方窗口值的一半**（上例中是把发送方窗口值24修改为12）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

### **2.3  快重传（Fast Retransmit）和快恢复（Fast Recovery）结合**

**快重传**是指，如果发送端接收到**3个以上的重复ACK**，不需要等到重传定时器溢出就重新传递，所以叫做**快速重传**，而快速重传以后，因为走的不是慢启动而是拥塞避免算法，所以这又叫做**快速恢复算法**。

如果没有**快速重传**和**快速恢复**，TCP将会使用**定时器**来要求传输暂停。在暂停这段时间内，没有新的数据包被发送。所以快速重传和快速恢复旨在快速恢复丢失的数据包。

#### **2.3.1  具体介绍**

![](../../.gitbook/assets/image%20%28221%29.png)

快重传的机制还是比较好理解的，如图所示，接收方发现M3丢失，则立即发送对M2的重复确认。一旦发送方一连收到三个M2的重复确认就应当立即重传M3，也就是发送方收到第四个对M2的确认时。

![](../../.gitbook/assets/image%20%28173%29.png)

与快重传配合使用的还有快恢复算法，结合上图的实例来分析，其过程有以下两个要点：

1. 当发送方在cwnd=24时连续收到三个重复确认，就把慢开始门限ssthresh减半（就是上图中的24修改为12;
2. 接下来不执行慢开始算法，而是把cwnd值设置为门限ssthresh减半后的数值（即cwnd不是设置为1而是设置为12），然后开始执行的是拥塞避免算法，使拥塞窗口缓慢地线性增大

这里为什么替换掉了慢开始算法呢？

这是因为收到重复的ACK不仅仅告诉我们一个分组丢失了，由于接收方只有在收到另一个报文段时才会产生重复的ACK，所以还告诉我们该报文段已经进入了接收方的缓存。也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。 



