# 2.2 聚集和非聚集索引

## 1. 简介

      聚集索引以及非聚集索引用的是**B+树**索引。

> 该表包含3个字段，如下：  
>  **id:**主键  
>  **plname：**编程语言名称  
>  **ranking：**排名

| id | plname | ranking |
| :--- | :--- | :--- |
| 15 | C | 2 |
| 16 | Java | 1 |
| 18 | Php | 6 |
| 23 | C\# | 5 |
| 26 | C++ | 3 |
| 29 | Ada | 17 |
| 50 | Go | 12 |
| 52 | Lisp | 15 |
| ... | ... | ... |

## 2. 聚集索引

* **唯一性**，由其定义决定；
* 对MySQL：**主键即索引**；
* 优点： **查询速度快**
* 缺点：**耗费时间以及性能**
*  索引和数据存储在一块

###  2.1 定义

       数据行的**物理顺序**与列值（一般是主键的那一列）的**逻辑顺序**相同，一个表中**只能拥有**一个聚集索引。

       新华字典，聚集索引就像是**拼音目录**

       如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。

![](../../.gitbook/assets/image%20%286%29.png)

 聚集索引的**好处**:

       索引的**叶子节点就是对应的数据节点**（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以**直接获取到对应的全部列的数据**，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的**速度**往往会更占优势。

### 2.2 创建聚集索引

如果不创建索引，系统会**自动创建**一个隐含列作为表的聚集索引。

1.创建表的时候**指定主键**（注意：**SQL Sever默认主键为聚集索引**，也可以指定为非聚集索引，而**MySQL**里**主键就是聚集索引**）

```sql
create table t1(
    id int primary key,
    name nvarchar(255)
)
```

2.创建表后添加聚集索引

**SQL Server**

```sql
create clustered index clustered_index on table_name(colum_name)
```

**MySQL**

```sql
alter table table_name add primary key(colum_name)
```

值得注意的是，最好还是在**创建表**的时候**添加聚集索引**，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会**根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能**。

## 3. 非聚集索引

     索引数据和存储数据是分离的。

###  3.1 定义

          该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

          非聚集索引，分成普通索引，唯一索引，全文索引。

          非聚集索引就像新华字典的**偏旁字典**，他结构顺序与实际存放顺序不一定一致。

![&#x975E;&#x805A;&#x96C6;&#x7D22;&#x5F15;&#x5B9E;&#x9645;&#x5B58;&#x653E;&#x7684;&#x793A;&#x610F;&#x56FE;](../../.gitbook/assets/image%20%2897%29.png)

        在SQL Server里面会对查询自动优化，选择适合的索引，因此如果**在数据量不大**的情况下，SQL Server很有可能不会使用非聚集索引进行查询，而是使用**聚集索引**进行查询，即便需要扫描整个聚集索引，效率也比使用非聚集索引效率要高

### 3.2 非聚集索引的二次查询问题

     非聚集索引**叶节点仍然是索引节点**，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

![&#x4E8C;&#x7EA7;&#x7D22;&#x5F15;](../../.gitbook/assets/image%20%2862%29.png)

### 3.3 如何解决非聚集索引的二次查询问题

#### **复合索引（覆盖索引）**

建立两列以上的索引，即可查询复合索引里的列的数据而不需要进行回表二次查询，如index\(col1, col2\)，执行下面的语句

```sql
select col1, col2 from t1 where col1 = '213';
```

要注意使用复合索引需要满足**最左侧索引的原则**，也就是查询的时候如果where条件里面没有最左边的一到多列，索引就不会起作用。

在SQL Server中还有include的用法，可以把非聚集索引里包含的列包含进来，而不一定需要建立复合索引。

## 4. 总结

简单概括：

* 聚集索引就是以**主键**创建的索引
* 非聚集索引就是以**非主键**创建的索引

区别：

* 聚集索引在叶子节点存储的是**表中的数据**
* 非聚集索引在叶子节点存储的是**主键和索引列**
* 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。\(拿到主键再查找这个过程叫做**回表**\)

**非聚集索引也叫做二级索引**，不用纠结那么多名词，将其等价就行了~

非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。

* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了\(最左匹配原则–&gt;后面有说\)
* **创建多个单列\(非聚集\)索引的时候，会生成多个索引树**\(所以过多创建索引会占用磁盘空间\)

![](https://i.imgur.com/keW6q8l.jpg)

