# 2.3 聚集和非聚集索引

## 1. 索引的分类

* 普通索引和唯一性索引：索引列的值的唯一性
* 单个索引和复合索引：索引列所包含的列数
* 聚簇索引与非聚簇索引：聚簇索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。

主键：指字段 唯一、不为空值的列；

主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；

自增主键：字段类型为数字、自增、并且是主键；

唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。

## 2. 简介

        **主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。**

         ****在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。

         InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。

      聚集索引以及非聚集索引用的是**B+树**索引。

> 该表包含3个字段，如下：  
>  **id:**主键  
>  **plname：**编程语言名称  
>  **ranking：**排名

| id | plname | ranking |
| :--- | :--- | :--- |
| 15 | C | 2 |
| 16 | Java | 1 |
| 18 | Php | 6 |
| 23 | C\# | 5 |
| 26 | C++ | 3 |
| 29 | Ada | 17 |
| 50 | Go | 12 |
| 52 | Lisp | 15 |
| ... | ... | ... |

## 2. 聚集索引

* **唯一性**，由其定义决定；
* 对MySQL：**主键即索引**；
* 优点： **查询速度快**
* 缺点：**耗费时间以及性能**
*  索引和数据存储在一块

###  2.1 定义

       数据行的**物理顺序**与列值（一般是主键的那一列）的**逻辑顺序**相同，一个表中**只能拥有**一个聚集索引。

       新华字典，聚集索引就像是**拼音目录**

       如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。

![](../../.gitbook/assets/image%20%2818%29.png)

 聚集索引的**好处**:

       索引的**叶子节点就是对应的数据节点**（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以**直接获取到对应的全部列的数据**，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的**速度**往往会更占优势。

### 2.2 创建聚集索引

如果不创建索引，系统会**自动创建**一个隐含列作为表的聚集索引。

1.创建表的时候**指定主键**（注意：**SQL Sever默认主键为聚集索引**，也可以指定为非聚集索引，而**MySQL**里**主键就是聚集索引**）

```sql
create table t1(
    id int primary key,
    name nvarchar(255)
)
```

2.创建表后添加聚集索引

**SQL Server**

```sql
create clustered index clustered_index on table_name(colum_name)
```

**MySQL**

```sql
alter table table_name add primary key(colum_name)
```

值得注意的是，最好还是在**创建表**的时候**添加聚集索引**，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会**根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能**。

## 3. 非聚集索引

     索引数据和存储数据是分离的。

###  3.1 定义

          该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

          非聚集索引，分成普通索引，唯一索引，全文索引。

          非聚集索引就像新华字典的**偏旁字典**，他结构顺序与实际存放顺序不一定一致。

![&#x975E;&#x805A;&#x96C6;&#x7D22;&#x5F15;&#x5B9E;&#x9645;&#x5B58;&#x653E;&#x7684;&#x793A;&#x610F;&#x56FE;](../../.gitbook/assets/image%20%28381%29.png)

        在SQL Server里面会对查询自动优化，选择适合的索引，因此如果**在数据量不大**的情况下，SQL Server很有可能不会使用非聚集索引进行查询，而是使用**聚集索引**进行查询，即便需要扫描整个聚集索引，效率也比使用非聚集索引效率要高

### 3.2 非聚集索引的二次查询问题

     非聚集索引**叶节点仍然是索引节点**，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

![&#x4E8C;&#x7EA7;&#x7D22;&#x5F15;](../../.gitbook/assets/image%20%28231%29.png)

### 3.3 如何解决非聚集索引的二次查询问题

#### **复合索引（覆盖索引）**

建立两列以上的索引，即可查询复合索引里的列的数据而不需要进行回表二次查询，如index\(col1, col2\)，执行下面的语句

```sql
select col1, col2 from t1 where col1 = '213';
```

要注意使用复合索引需要满足**最左侧索引的原则**，也就是查询的时候如果where条件里面没有最左边的一到多列，索引就不会起作用。

在SQL Server中还有include的用法，可以把非聚集索引里包含的列包含进来，而不一定需要建立复合索引。

## 4. 总结

区别：

* 聚集索引在叶子节点存储的是**表中的数据**
* 非聚集索引在叶子节点存储的是**主键和索引列**
* 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。\(拿到主键再查找这个过程叫做**回表**\)

非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。

* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了\(最左匹配原则–&gt;后面有说\)
* **创建多个单列\(非聚集\)索引的时候，会生成多个索引树**\(所以过多创建索引会占用磁盘空间\)

![](../../.gitbook/assets/image%20%28383%29.png)

在创建多列索引中也涉及到了一种特殊的索引–&gt;**覆盖索引**

* 我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值
* 最终还是要“回表”，也就是要通过主键**再**查找一次。这样就会比较慢
* 覆盖索引就是把要**查询出的列和索引是对应的**，不做回表操作！

比如说：

* 现在我创建了索引`(username,age)`，在查询数据的时候：`select username , age from user where username = 'Java3y' and age = 20`。
* 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~
* 所以，能使用覆盖索引就尽量使用吧~

