# 2.1 索引的基础知识

##  1. Mysql的基本存储结构

首先Mysql的基本存储结构是**页**\(记录都存在页里边\)：

![&#x9875;&#x7ED3;&#x6784;&#x793A;&#x610F;&#x56FE;](../../.gitbook/assets/image%20%28106%29.png)

![](../../.gitbook/assets/image%20%2860%29.png)

* **各个数据页**可以组成一个**双向链表**
* 而**每个数据页中的记录**又可以组成一个**单向**链表 

![](../../.gitbook/assets/image%20%28218%29.png)

* 每个数据页都会为存储在它里边儿的记录生成一个**页目录**，在通过**主键**查找某条记录的时候可以在页目录中使用**二分法快速定位**到对应的槽，然后**再遍历该槽对应分组中的记录**即可快速找到指定的记录
* 以**其他列**\(非主键\)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。

所以说，如果我们写`select * from user where username = 'Java3y'`这样没有进行任何优化的sql语句，默认会这样做：

* 定位到记录所在的页 
  * 需要**遍历双向链表，找到所在的页**
* 从所在的页内中查找相应的记录 
  * 由于**不是根据主键查询，只能遍历所在页的单链表**了

很明显，在数据量很大的情况下这样查找会**很慢**！

## 2. 索引提高检索速度

 **将无序的数据变成有序\(相对\)**：

![](../../.gitbook/assets/image%20%2869%29.png)

 找到id为8的记录简要步骤:

![](../../.gitbook/assets/image%20%28217%29.png)

**没有用索引**我们是需要**遍历双向链表**来定位对应的页，现在通过**“目录”**就可以很快地定位到对应的页上了！

其实底层结构就是**B+树**，B+树作为树的一种实现，能够让我们**很快地**查找出对应的记录。

## 3. 索引降低增删改的速度

### 3.1 B+树索引

* B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。
* **要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度
* 为什么使用B+树？言简意赅，就是因为：
  * 1.文件很大，不可能全部存储在内存中，故要存储到磁盘上
  * 2.索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数（为什么使用B-/+Tree，还跟磁盘存取原理有关。）
  * 3.**局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数，（在许多操作系统中，页得大小通常为4k）**
  * **4.数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，\(由于节点中有两个数组，所以地址连续\)。而红黑树这种结构，h**明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性

### 3.2 Hash索引

* 本质上就是**把键值换算成新的哈希值**，根据这个**哈希值来定位**。

![Hash &#x7D22;&#x5F15;](../../.gitbook/assets/image%20%28241%29.png)

哈希索引有好几个局限\(根据他本质的原理可得\)：

* 哈希索引也没办法利用索引完成**排序**
* 不支持**最左匹配原则**
* 在有大量重复键值情况下，哈希索引的效率也是极低的—-&gt;**哈希碰撞**问题。
* **不支持范围查询**

## 4. 聚集和非聚集索引

简单概括：

* 聚集索引就是以**主键**创建的索引
* 非聚集索引就是以**非主键**创建的索引

区别：

* 聚集索引在叶子节点存储的是**表中的数据**
* 非聚集索引在叶子节点存储的是**主键和索引列**
* 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。\(拿到主键再查找这个过程叫做**回表**\)

非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。

* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了\(最左匹配原则–&gt;后面有说\)
* **创建多个单列\(非聚集\)索引的时候，会生成多个索引树**\(所以过多创建索引会占用磁盘空间\)

![](../../.gitbook/assets/image%20%28240%29.png)

在创建多列索引中也涉及到了一种特殊的索引–&gt;**覆盖索引**

* 我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值
* 最终还是要“回表”，也就是要通过主键**再**查找一次。这样就会比较慢
* 覆盖索引就是把要**查询出的列和索引是对应的**，不做回表操作！

比如说：

* 现在我创建了索引`(username,age)`，在查询数据的时候：`select username , age from user where username = 'Java3y' and age = 20`。
* 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~
* 所以，能使用覆盖索引就尽量使用吧~

