# 2.1 索引的基础知识

## 1. **数据库索引**

　　**索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B\_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。

![&#x7D22;&#x5F15;.png-36.9kB](http://static.zybuluo.com/Rico123/z13w648etta3tb90di3btu5b/%E7%B4%A2%E5%BC%95.png)

　　上图显示了一种索引方式。左边是数据库中的数据表，有col1和col2两个字段，一共有15条记录；右边是以col2列为索引列的B\_TREE索引，每个节点包含索引的键值和对应数据表地址的指针，这样就可以都过B\_TREE在 **O\(logn\)** 的时间复杂度内获取相应的数据，这样明显地加快了检索的速度。 

## 2. Mysql的基本存储结构

首先Mysql的基本存储结构是**页**\(记录都存在页里边\)：

![&#x9875;&#x7ED3;&#x6784;&#x793A;&#x610F;&#x56FE;](../../.gitbook/assets/image%20%28167%29.png)

![](../../.gitbook/assets/image%20%2894%29.png)

* **各个数据页**可以组成一个**双向链表**
* 而**每个数据页中的记录**又可以组成一个**单向**链表 
* **每个数据页**都会为存储在它里边儿的记录生成一个**页目录**，在通过**主键**查找某条记录的时候可以在页目录中使用**二分法快速定位**到对应的槽，然后**再遍历该槽对应分组中的记录**即可快速找到指定的记录
* 以**其他列**\(非主键\)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。

所以说，如果我们写`select * from user where username = 'Java3y'`这样没有进行任何优化的sql语句，默认会这样做：

* 定位到记录所在的页 
  * 需要**遍历双向链表，找到所在的页**
* 从所在的页内中查找相应的记录 
  * 由于**不是根据主键查询，只能遍历所在页的单链表**了

很明显，在数据量很大的情况下这样查找会**很慢**！

## 2. 索引提高检索速度

 **将无序的数据变成有序\(相对\)**：

![](../../.gitbook/assets/image%20%28107%29.png)

 找到id为8的记录简要步骤:

![](../../.gitbook/assets/image%20%28378%29.png)

**没有用索引**我们是需要**遍历双向链表**来定位对应的页，现在通过**“目录”**就可以很快地定位到对应的页上了！

其实底层结构就是**B+树**，B+树作为树的一种实现，能够让我们**很快地**查找出对应的记录。

## 3. 索引降低增删改的速度

### 3.1 B+树索引

* B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。
* **要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度
* 为什么使用B+树？言简意赅，就是因为：
  * 1.文件很大，不可能全部存储在内存中，故要存储到磁盘上
  * 2.索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数（为什么使用B-/+Tree，还跟磁盘存取原理有关。）
  * 3.**局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数，（在许多操作系统中，页得大小通常为4k）**
  * **4.数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，\(由于节点中有两个数组，所以地址连续\)。而红黑树这种结构，h**明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性

### 3.2 Hash索引

* 本质上就是**把键值换算成新的哈希值**，根据这个**哈希值来定位**。

![Hash &#x7D22;&#x5F15;](../../.gitbook/assets/image%20%28417%29.png)

哈希索引有好几个局限\(根据他本质的原理可得\)：

* 哈希索引也没办法利用索引完成**排序**
* 不支持**最左匹配原则**
* 在有大量重复键值情况下，哈希索引的效率也是极低的—-&gt;**哈希碰撞**问题。
* **不支持范围查询**



