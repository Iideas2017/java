# 概念



![](../../.gitbook/assets/image%20%2891%29.png)

## 1.  ACID

### **1.1 原子性（Atomicity）**

事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态之一。

* 全部执行成功
* 全部执行失败

任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。

### **1.2 一致性（Consistency）**

     事务的一致性是指事务的执行**不能破坏数据库数据的完整性和一致性**，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。

比如：如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱。

### **1.3 隔离性（Isolation）**

     事务的隔离性是指在并发环境中，并发的事务是**互相隔离**的，一个事务的执行不能被其它事务干扰。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间。

    一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务是不能互相干扰的。

隔离性分4个级别，下面会介绍。

### **1.4 持久性（Duration）**

     事务的持久性是指**事务一旦提交后**，数据库中的数据**必须被永久的保存下来**。即使服务器系统崩溃或服务器宕机等故障。只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。

## 2. 事务隔离级别

### **2.1 读未提及（READ\_UNCOMMITTED）**

读未提及，该隔离级别允许脏读取，其隔离级别是最低的。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务；而以此同时，允许另一个事务也能够访问该数据。

#### **脏读示例：**

在事务A和事务B同时执行时可能会出现如下场景：

| 时间 | 事务A（存款） | 事务B（取款） |
| :--- | :--- | :--- |
| T1 | 开始事务 | —— |
| T2 | —— | 开始事务 |
| T3 | —— | 查询余额（1000元） |
| T4 | —— | 取出1000元（余额0元） |
| T5 | 查询余额（0元） | —— |
| T6 | —— | 撤销事务（余额恢复1000元） |
| T7 | 存入500元（余额500元） | —— |
| T8 | 提交事务 | —— |

余额应该为1500元才对。请看T5时间点，事务A此时查询的余额为0，这个数据就是**脏数据**，他是事务B造成的，很明显是事务没有进行隔离造成的。

### **2.2 读已提交（READ\_COMMITTED）**

读已提交是不同的时候执行的时候只能获取到已经提交的数据。  
 这样就不会出现上面的脏读的情况了。

#### **不可重复读示例**

 不可重复读是指在同一个事务内，两个**相同的查询**返回了**不同的结果**。 

| 时间 | 事务A（存款） | 事务B（取款） |
| :--- | :--- | :--- |
| T1 | 开始事务 | —— |
| T2 | —— | 开始事务 |
| T3 | —— | 查询余额（1000元） |
| T4 | 查询余额（1000元） | —— |
| T5 | —— | 取出1000元（余额0元） |
| T6 | —— | 提交事务 |
| T7 | 查询余额（0元） | —— |
| T8 | 提交事务 | —— |

事务A其实除了查询两次以外，其它什么事情都没做，结果钱就从1000编程0了，这就是不可重复读的问题。

### **2.3 可重复读（REPEATABLE\_READ）**

可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别阻止了不可重复读取和脏读，但是有可能出现幻读的数据。

**幻读**

    ~~幻读就是指**同样的事务**操作，在前后两个时间段内执行对**同一个数据项**的读取，可能出现不一致的结果。~~

| 时间 | 事务A（统计总存款） | 事务B（存款） |
| :--- | :--- | :--- |
| T1 | 开始事务 | —— |
| T2 | —— | 开始事务 |
| T3 | 统计总存款（1000元） | —— |
| T4 | —— | 存入100元 |
| T5 | —— | 提交事务 |
| T6 | 提交总存款（10100） | —— |
| T7 | 提交事务 | —— |

银行工作人员在一个事务中多次统计总存款时看到结果不一样。如果要解决幻读，那只能使用顺序读了。

 InnoDB和Falcon存储引擎通过**多版本并发控制**\(MVCC，Multiversion Concurrency Control\)机制解决了该问题

### **2.4 顺序读（SERIALIZABLE）**

顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。

## 3. 事务隔离级别对比

| 事务隔离级别 | 脏 读 | 不可重复读 | 幻 读 |
| :--- | :--- | :--- | :--- |
| 读未提及（READ\_UNCOMMITTED） | 允许 | 允许 | 允许 |
| 读已提交（READ\_COMMITTED） | 禁止 | 允许 | 允许 |
| 可重复读（REPEATABLE\_READ） | 禁止 | 禁止 | 允许 |
| 顺序读（SERIALIZABLE） | 禁止 | 禁止 | 禁止 |

> 4种事务隔离级别从上往下，级别越高，并发性越差，安全性就越来越高。  
>  一般数据默认级别是读以提交或可重复读。

  
 MySQL的默认隔离级别就是Repeatable read。

### 区别

#### 不可重复读 {#不可重复读}

> 不可重复读的重点是**修改**   
> 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了

#### 幻读 {#幻读}

> 幻读的重点在于**新增**或者**删除**   
> 同样的条件, 第1次和第2次读出来的记录数不一样

