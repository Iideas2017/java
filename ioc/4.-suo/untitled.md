# 4.1 分类

## 1. 锁的分类

![&#x6570;&#x636E;&#x5E93;&#x9501;](../../.gitbook/assets/image%20%28125%29.png)



首先，从锁的粒度，我们可以分成两大类：

* **表锁** 
  * 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
* **行锁** 
  * 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

不同的存储引擎支持的锁粒度是不一样的：

* **InnoDB行锁和表锁都支持**！
* **MyISAM只支持表锁**！

InnoDB只有通过**索引条件**检索数据**才使用行级锁**，否则，InnoDB将使用**表锁**

* 也就是说，**InnoDB的行锁是基于索引的**！

隐式锁：

* 对于`UPDATE、DELETE、INSERT`语句，**InnoDB**会**自动**给涉及数据集加排他锁（X\)
* **MyISAM**在执行查询语句`SELECT`前，会**自动**给涉及的所有表加**读锁**，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会**自动**给涉及的表加**写锁**

## 2.  表锁

**表锁下又分为两种模式**：

* 表读锁（Table Read Lock）
* 表写锁（Table Write Lock）
* 从下图可以清晰看到，在表读锁和表写锁的环境下：**读读不阻塞，读写阻塞，写写阻塞**！  
  * 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
  * 读写阻塞：当前用户在读数据，其他的用户**不能修改当前用户读的数据**，会加锁！
  * 写写阻塞：当前用户在修改数据，其他的用户**不能修改当前用户正在修改的数据**，会加锁！

![](../../.gitbook/assets/image%20%28138%29.png)

从上面已经看到了：**读锁和写锁是互斥的，读写操作是串行**。

* 如果某个进程想要获取读锁，**同时**另外一个进程想要获取写锁。在mysql里边，**写锁是优先于读锁的**！
* 写锁和读锁优先级的问题是可以通过参数调节的：`max_write_lock_count`和`low-priority-updates`
* **MyISAM可以**支持查询和插入操作的**并发**进行。可以通过系统变量`concurrent_insert`来指定哪种模式，在**MyISAM**中它默认是：如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从**表尾**插入记录。
* 但是**InnoDB存储引擎是不支持的**！

## 3. 行锁

我们使用Mysql一般是使用InnoDB存储引擎的。InnoDB和MyISAM有两个本质的区别：

* InnoDB支持行锁
* InnoDB支持事务

从上面也说了：我们是**很少手动加表锁**的。表锁对我们程序员来说几乎是透明的，即使InnoDB不走索引，加的表锁也是自动的！

InnoDB实现了以下**两种**类型的行锁。

* 共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 
  * 也叫做**读锁**：读锁是**共享**的，多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。
* 排他锁（X锁\)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 
  * 也叫做**写锁**：写锁是排他的，**写锁会阻塞其他的写锁和读锁**。

另外，**为了允许行锁和表锁共存，实现多粒度锁机制**，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**：

* **意向共享锁（IS）**：事务打算给数据行加**行共享锁**，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
* **意向排他锁（IX）**：事务打算给数据行加**行排他锁**，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
* 意向锁也是数据库隐式帮我们做了，**不需要程序员操心**！

