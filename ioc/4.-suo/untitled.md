# Untitled

## 1. 锁的分类

![&#x6570;&#x636E;&#x5E93;&#x9501;](../../.gitbook/assets/image%20%2868%29.png)



首先，从锁的粒度，我们可以分成两大类：

* **表锁** 
  * 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
* **行锁** 
  * 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

不同的存储引擎支持的锁粒度是不一样的：

* **InnoDB行锁和表锁都支持**！
* **MyISAM只支持表锁**！

InnoDB只有通过**索引条件**检索数据**才使用行级锁**，否则，InnoDB将使用**表锁**

* 也就是说，**InnoDB的行锁是基于索引的**！

隐式锁：

* 对于`UPDATE、DELETE、INSERT`语句，**InnoDB**会**自动**给涉及数据集加排他锁（X\)
* **MyISAM**在执行查询语句`SELECT`前，会**自动**给涉及的所有表加**读锁**，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会**自动**给涉及的表加**写锁**

## 2.  表锁

**表锁下又分为两种模式**：

* 表读锁（Table Read Lock）
* 表写锁（Table Write Lock）
* 从下图可以清晰看到，在表读锁和表写锁的环境下：**读读不阻塞，读写阻塞，写写阻塞**！  
  * 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
  * 读写阻塞：当前用户在读数据，其他的用户**不能修改当前用户读的数据**，会加锁！
  * 写写阻塞：当前用户在修改数据，其他的用户**不能修改当前用户正在修改的数据**，会加锁！

![](../../.gitbook/assets/image%20%2876%29.png)

从上面已经看到了：**读锁和写锁是互斥的，读写操作是串行**。

* 如果某个进程想要获取读锁，**同时**另外一个进程想要获取写锁。在mysql里边，**写锁是优先于读锁的**！
* 写锁和读锁优先级的问题是可以通过参数调节的：`max_write_lock_count`和`low-priority-updates`
* **MyISAM可以**支持查询和插入操作的**并发**进行。可以通过系统变量`concurrent_insert`来指定哪种模式，在**MyISAM**中它默认是：如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从**表尾**插入记录。
* 但是**InnoDB存储引擎是不支持的**！

## 3. 行锁细讲

我们使用Mysql一般是使用InnoDB存储引擎的。InnoDB和MyISAM有两个本质的区别：

* InnoDB支持行锁
* InnoDB支持事务

从上面也说了：我们是**很少手动加表锁**的。表锁对我们程序员来说几乎是透明的，即使InnoDB不走索引，加的表锁也是自动的！

我们应该**更加关注行锁的内容**，因为InnoDB一大特性就是支持行锁！

InnoDB实现了以下**两种**类型的行锁。

* 共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。  
  * 也叫做**读锁**：读锁是**共享**的，多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。
* 排他锁（X锁\)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。  
  * 也叫做**写锁**：写锁是排他的，**写锁会阻塞其他的写锁和读锁**。

看完上面的有没有发现，在一开始所说的：X锁，S锁，读锁，写锁，共享锁，排它锁其实**总共就两个锁**，只不过它们**有多个名字罢了**~~~

> Intention locks do not block anything except full table requests \(for example, LOCK TABLES … WRITE\). The main purpose of intention locks **is to show that someone is locking a row, or going to lock a row in the table**.

另外，**为了允许行锁和表锁共存，实现多粒度锁机制**，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**：

* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
* 意向锁也是数据库隐式帮我们做了，**不需要程序员操心**！

#### 2.2.1MVCC和事务的隔离级别 {#221mvcc和事务的隔离级别}

数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，**锁的应用最终导致不同事务的隔离级别**

MVCC\(Multi-Version Concurrency Control\)多版本并发控制，可以简单地认为：**MVCC就是行级锁的一个变种\(升级版\)**。

* 事务的隔离级别就是**通过锁的机制来实现**，只不过**隐藏了加锁细节**

在**表锁中我们读写是阻塞**的，基于提升并发性能的考虑，**MVCC一般读写是不阻塞的**\(所以说MVCC很多情况下避免了加锁的操作\)

* MVCC实现的**读写不阻塞**正如其名：**多版本**并发控制—&gt;通过一定机制生成一个数据请求**时间点的一致性数据快照（Snapshot\)**，并用这个快照来提供一定级别（**语句级或事务级**）的**一致性读取**。从用户的角度来看，好像是**数据库可以提供同一数据的多个版本**。

快照有**两个级别**：

* 语句级  
  * 针对于`Read committed`隔离级别
* 事务级别  
  * 针对于`Repeatable read`隔离级别

我们在初学的时候已经知道，事务的隔离级别有**4种**：

* Read uncommitted  
  * 会出现脏读，不可重复读，幻读
* Read committed  
  * 会出现不可重复读，幻读
* Repeatable read  
  * 会出现幻读\(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！\)
* Serializable  
  * 串行，避免以上的情况！

`Read uncommitted`会出现的现象—&gt;脏读：**一个事务读取到另外一个事务未提交的数据**

* 例子：A向B转账，**A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了**！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。
* 出现脏读的本质就是因为**操作\(修改\)完该数据就立马释放掉锁**，导致读的数据就变成了无用的或者是**错误的数据**。

`Read committed`**避免脏读**的做法其实很简单：

* 就是把**释放锁的位置调整到事务提交之后**，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作

但`Read committed`出现的现象—&gt;不可重复读：**一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改**

* 注：**A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】**

上面也说了，`Read committed`是**语句级别**的快照！**每次读取的都是当前最新的版本**！

`Repeatable read`避免不可重复读是**事务级别**的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。

呃…如果还是不太清楚，我们来看看InnoDB的MVCC是怎么样的吧\(摘抄《高性能MySQL》\)

