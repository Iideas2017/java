# 1.2 B、B-、B+和 B\* tree

## 1. 概述

 **B tree：** 二叉树（Binary tree），每个节点只能存储一个数。  
 **B-tree：**B树（B-Tree，并不是B“减”树，横杠为连接符，容易被误导）  
 B树属于多叉树又名平衡多路查找树。每个节点可以多个数（由磁盘大小决定）。  
 **B+tree** 和 **B\*tree** 都是 B-tree的变种。

## 2. 索引为什么是用B树呢？

       一般来说，索引本身也很大，不可能全部存储在内存中，因此**索引往往以索引文件**的形式**存储的磁盘上**。这样的话，索引查找过程中就要产生**磁盘I/O**消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽**量减少查找过程中磁盘I/O的存取次数。而B-/+/\*Tree**，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘IO的读取次数。

## 3. B-、B+和 B\* tree

### 3.1 B-tree

![](../../.gitbook/assets/image%20%2818%29.png)

每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。

B-tree巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页（每页为4K），这样每个节点只需要一次I/O就可以完全载入。  
 B-tree 的数据可以存在任何节点中。

### 3.2 B+ tree

![](../../.gitbook/assets/image%20%2864%29.png)

B+tree 是 B-tree 的变种，数据只能存储在叶子节点。

B+tree 是 B-tree 的变种，B+tree 数据只存储在叶子节点中。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;

> 如果每个节点能存放M个数据，每个节点的数据在M/2到M之间。预留出空间可以插入新的数据。

### 3.3 B\*tree

![](../../.gitbook/assets/image%20%28120%29.png)

      B\*tree 每个磁盘块中又添加了对下一个磁盘块的引用。这样可以在当前磁盘块满时，不用**扩容直接存储到下一个临近磁盘块**中。当两个邻近的磁盘块都满时，这两个磁盘块各分出1/3的数据重新分配一个磁盘块，这样这三个磁盘块的数据都为2/3。

     如果每个节点能存放M个数据，每个节点的数据在**2M/3到M**之间。预留出空间可以插入新的数据。

     在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得**B\*树**分解次数变得更少。

