# 1.3 B、B-、B+和 B\* tree

## 1. 概述

 **B tree：** 二叉树（Binary tree），每个节点只能存储一个数。  
 **B-tree：**B树（B-Tree，并不是B“减”树，横杠为连接符，容易被误导）  
 B树属于多叉树又名平衡多路查找树。每个节点可以多个数（由磁盘大小决定）。  
 **B+tree** 和 **B\*tree** 都是 B-tree的变种。

## 2. 索引为什么是用B树呢？

       一般来说，索引本身也很大，不可能全部存储在内存中，因此**索引往往以索引文件**的形式**存储的磁盘上**。这样的话，索引查找过程中就要产生**磁盘I/O**消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽**量减少查找过程中磁盘I/O的存取次数。而B-/+/\*Tree**，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘IO的读取次数。

文件索引和数据库索引使用B+树：

　　文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点\(父子\)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。

## B+-tree和 B 树？

B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引：

* B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针\(红色部分\)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；
* B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；
* **数据库索引采用B+树而不是B树的主要原因：**B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而**B树只能中序遍历所有节点，效率太低**。

## 3. B-、B+和 B\* tree

### 3.1 B-tree 平衡多路查找树

B\_TREE是一种平衡多路查找树，是一种动态查找效率很高的树形结构。B\_TREE中**所有结点的孩子结点的最大值**称为B\_TREE的阶，B\_TREE的阶通常用**m表示**，简称为**m叉树**。一般来说，应该是m&gt;=3。一颗m阶的B\_TREE或是一颗空树，或者是满足下列条件的m叉树：

* 树中每个结点最多有m个孩子结点；
* 若根结点不是叶子节点，则根结点至少有2个孩子结点；
* 除根结点外，其它结点至少有\(m/2的上界\)个孩子结点；
* 结点的结构如下图所示，其中，n为结点中关键字个数，\(m/2的上界\)-1 &lt;= n &lt;= m-1；di\(1&lt;=i&lt;=n\)为该结点的n个关键字值的第i个，且di&lt; d\(i+1\)；ci\(0&lt;=i&lt;=n\)为该结点孩子结点的指针，且ci所指向的节点的关键字均大于或等于di且小于d\(i+1\)；

![](../../.gitbook/assets/image%20%28292%29.png)

* 所有的叶结点都在同一层上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。

![](../../.gitbook/assets/image%20%2852%29.png)

每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。

B-tree巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页（每页为4K），这样每个节点只需要一次I/O就可以完全载入。  
 B-tree 的数据可以存在任何节点中。

B\_TREE的查找类似**二叉排序树的查找**，不同的是B-树**每个结点上是多关键码的有序表**，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。由于B\_TREE的高检索效率，B-树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。

### 3.2 B+ tree

![](../../.gitbook/assets/image%20%28247%29.png)

B+Tree是应文件系统所需而产生的一种B\_TREE树的变形树。一棵m阶的B+树和m阶的B\_TREE的差异在于以下三点：

* n 棵子树的结点中含有n个关键码；
* 所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；
* 非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。

B+tree 是 B-tree 的变种，数据只能存储在叶子节点。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;

下图为一棵3阶的B+树。通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。  
 在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。只是在查找时，若非终端结点上的关键码等于给定值，并不终止，而是继续向下直到叶子结点。因此，对于B+树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。

![&#x4E00;&#x68F5;3&#x9636;&#x7684;B+&#x6811;.jpg-29.9kB](http://static.zybuluo.com/Rico123/ynugdx0avoy5blfq6gkb0tv2/3%E9%98%B6B+%E6%A0%91.jpg)

> 如果每个节点能存放M个数据，每个节点的数据在M/2到M之间。预留出空间可以插入新的数据。

### 3.3 B\*tree

![](../../.gitbook/assets/image%20%28447%29.png)

      B\*tree 每个磁盘块中又添加了对下一个磁盘块的引用。这样可以在当前磁盘块满时，不用**扩容直接存储到下一个临近磁盘块**中。当两个邻近的磁盘块都满时，这两个磁盘块各分出1/3的数据重新分配一个磁盘块，这样这三个磁盘块的数据都为2/3。

     如果每个节点能存放M个数据，每个节点的数据在**2M/3到M**之间。预留出空间可以插入新的数据。

     在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得**B\*树**分解次数变得更少。

